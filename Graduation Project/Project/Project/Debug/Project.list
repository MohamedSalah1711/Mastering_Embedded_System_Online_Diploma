
Project.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000130  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000010b4  08000130  08000130  00010130  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000014  080011e4  080011e4  000111e4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080011f8  080011f8  00020018  2**0
                  CONTENTS
  4 .ARM          00000000  080011f8  080011f8  00020018  2**0
                  CONTENTS
  5 .preinit_array 00000000  080011f8  080011f8  00020018  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080011f8  080011f8  000111f8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080011fc  080011fc  000111fc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000018  20000000  08001200  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000006c  20000018  08001218  00020018  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  20000084  08001218  00020084  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00020018  2**0
                  CONTENTS, READONLY
 12 .debug_info   00002332  00000000  00000000  00020041  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000007af  00000000  00000000  00022373  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00000b7c  00000000  00000000  00022b22  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00000208  00000000  00000000  000236a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000001a0  00000000  00000000  000238a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macro  000017ce  00000000  00000000  00023a48  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   00000b39  00000000  00000000  00025216  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_str    00006326  00000000  00000000  00025d4f  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      0000007b  00000000  00000000  0002c075  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00000634  00000000  00000000  0002c0f0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000130 <__do_global_dtors_aux>:
 8000130:	b510      	push	{r4, lr}
 8000132:	4c05      	ldr	r4, [pc, #20]	; (8000148 <__do_global_dtors_aux+0x18>)
 8000134:	7823      	ldrb	r3, [r4, #0]
 8000136:	b933      	cbnz	r3, 8000146 <__do_global_dtors_aux+0x16>
 8000138:	4b04      	ldr	r3, [pc, #16]	; (800014c <__do_global_dtors_aux+0x1c>)
 800013a:	b113      	cbz	r3, 8000142 <__do_global_dtors_aux+0x12>
 800013c:	4804      	ldr	r0, [pc, #16]	; (8000150 <__do_global_dtors_aux+0x20>)
 800013e:	f3af 8000 	nop.w
 8000142:	2301      	movs	r3, #1
 8000144:	7023      	strb	r3, [r4, #0]
 8000146:	bd10      	pop	{r4, pc}
 8000148:	20000018 	.word	0x20000018
 800014c:	00000000 	.word	0x00000000
 8000150:	080011cc 	.word	0x080011cc

08000154 <frame_dummy>:
 8000154:	b508      	push	{r3, lr}
 8000156:	4b03      	ldr	r3, [pc, #12]	; (8000164 <frame_dummy+0x10>)
 8000158:	b11b      	cbz	r3, 8000162 <frame_dummy+0xe>
 800015a:	4903      	ldr	r1, [pc, #12]	; (8000168 <frame_dummy+0x14>)
 800015c:	4803      	ldr	r0, [pc, #12]	; (800016c <frame_dummy+0x18>)
 800015e:	f3af 8000 	nop.w
 8000162:	bd08      	pop	{r3, pc}
 8000164:	00000000 	.word	0x00000000
 8000168:	2000001c 	.word	0x2000001c
 800016c:	080011cc 	.word	0x080011cc

08000170 <Dc_Motors_Init>:
 *
 *  Created on: Dec 5, 2023
 *      Author: mohamed salah
 */
#include "DC_Motors.h"
void Dc_Motors_Init(void){
 8000170:	b580      	push	{r7, lr}
 8000172:	b082      	sub	sp, #8
 8000174:	af00      	add	r7, sp, #0
	//init PWM to make 500HZ and 50% Duty cycle
	//Timer_CTC_Config CTC_con={INT_OFF,11,1600,800,0,1};
	//Timer_CTC_Output_Mode	Modee = {PWM1,Enable_Pre,ActiveLow};
	GPIO_PIN_Config DIO_Config={MOTOR1_PIN1,Max_speed_10MHZ,OUTPUT_PP};
 8000176:	4a35      	ldr	r2, [pc, #212]	; (800024c <Dc_Motors_Init+0xdc>)
 8000178:	1d3b      	adds	r3, r7, #4
 800017a:	6812      	ldr	r2, [r2, #0]
 800017c:	4611      	mov	r1, r2
 800017e:	8019      	strh	r1, [r3, #0]
 8000180:	3302      	adds	r3, #2
 8000182:	0c12      	lsrs	r2, r2, #16
 8000184:	701a      	strb	r2, [r3, #0]
	 * 	Each Motor need one pwm channel and 2 output pins
	 *
	 */
	//init Motor 1
	//MCAL_CTC_GPIO_Init(MOTORS_PWM_TIMER,&CTC_con,&Modee);
	MCAL_GPIO_Init(MOTOR1_PORT,&DIO_Config);
 8000186:	1d3b      	adds	r3, r7, #4
 8000188:	4619      	mov	r1, r3
 800018a:	4831      	ldr	r0, [pc, #196]	; (8000250 <Dc_Motors_Init+0xe0>)
 800018c:	f000 fd20 	bl	8000bd0 <MCAL_GPIO_Init>
	DIO_Config.Pin_Num = MOTOR1_PIN2;
 8000190:	2305      	movs	r3, #5
 8000192:	713b      	strb	r3, [r7, #4]
	MCAL_GPIO_Init(MOTOR1_PORT,&DIO_Config);
 8000194:	1d3b      	adds	r3, r7, #4
 8000196:	4619      	mov	r1, r3
 8000198:	482d      	ldr	r0, [pc, #180]	; (8000250 <Dc_Motors_Init+0xe0>)
 800019a:	f000 fd19 	bl	8000bd0 <MCAL_GPIO_Init>
	//init Motor 2
	//CTC_con.Channel_Num=2;
	//MCAL_CTC_GPIO_Init(MOTORS_PWM_TIMER,&CTC_con,&Modee);
	DIO_Config.Pin_Num = MOTOR2_PIN1;
 800019e:	2306      	movs	r3, #6
 80001a0:	713b      	strb	r3, [r7, #4]
	MCAL_GPIO_Init(MOTOR2_PORT,&DIO_Config);
 80001a2:	1d3b      	adds	r3, r7, #4
 80001a4:	4619      	mov	r1, r3
 80001a6:	482a      	ldr	r0, [pc, #168]	; (8000250 <Dc_Motors_Init+0xe0>)
 80001a8:	f000 fd12 	bl	8000bd0 <MCAL_GPIO_Init>
	DIO_Config.Pin_Num = MOTOR2_PIN2;
 80001ac:	2307      	movs	r3, #7
 80001ae:	713b      	strb	r3, [r7, #4]
	MCAL_GPIO_Init(MOTOR2_PORT,&DIO_Config);
 80001b0:	1d3b      	adds	r3, r7, #4
 80001b2:	4619      	mov	r1, r3
 80001b4:	4826      	ldr	r0, [pc, #152]	; (8000250 <Dc_Motors_Init+0xe0>)
 80001b6:	f000 fd0b 	bl	8000bd0 <MCAL_GPIO_Init>
	//init Motor 3
	//CTC_con.Channel_Num=3;
	//MCAL_CTC_GPIO_Init(MOTORS_PWM_TIMER,&CTC_con,&Modee);
	DIO_Config.Pin_Num = MOTOR3_PIN1;
 80001ba:	2300      	movs	r3, #0
 80001bc:	713b      	strb	r3, [r7, #4]
	MCAL_GPIO_Init(MOTOR3_PORT,&DIO_Config);
 80001be:	1d3b      	adds	r3, r7, #4
 80001c0:	4619      	mov	r1, r3
 80001c2:	4824      	ldr	r0, [pc, #144]	; (8000254 <Dc_Motors_Init+0xe4>)
 80001c4:	f000 fd04 	bl	8000bd0 <MCAL_GPIO_Init>
	DIO_Config.Pin_Num = MOTOR3_PIN2;
 80001c8:	2301      	movs	r3, #1
 80001ca:	713b      	strb	r3, [r7, #4]
	MCAL_GPIO_Init(MOTOR3_PORT,&DIO_Config);
 80001cc:	1d3b      	adds	r3, r7, #4
 80001ce:	4619      	mov	r1, r3
 80001d0:	4820      	ldr	r0, [pc, #128]	; (8000254 <Dc_Motors_Init+0xe4>)
 80001d2:	f000 fcfd 	bl	8000bd0 <MCAL_GPIO_Init>
	//init Motor 4
	//CTC_con.Channel_Num=4;
	//MCAL_CTC_GPIO_Init(MOTORS_PWM_TIMER,&CTC_con,&Modee);
	DIO_Config.Pin_Num = MOTOR4_PIN1;
 80001d6:	230d      	movs	r3, #13
 80001d8:	713b      	strb	r3, [r7, #4]
	MCAL_GPIO_Init(MOTOR4_PORT,&DIO_Config);
 80001da:	1d3b      	adds	r3, r7, #4
 80001dc:	4619      	mov	r1, r3
 80001de:	481d      	ldr	r0, [pc, #116]	; (8000254 <Dc_Motors_Init+0xe4>)
 80001e0:	f000 fcf6 	bl	8000bd0 <MCAL_GPIO_Init>
	DIO_Config.Pin_Num = MOTOR4_PIN2;
 80001e4:	230e      	movs	r3, #14
 80001e6:	713b      	strb	r3, [r7, #4]
	MCAL_GPIO_Init(MOTOR4_PORT,&DIO_Config);
 80001e8:	1d3b      	adds	r3, r7, #4
 80001ea:	4619      	mov	r1, r3
 80001ec:	4819      	ldr	r0, [pc, #100]	; (8000254 <Dc_Motors_Init+0xe4>)
 80001ee:	f000 fcef 	bl	8000bd0 <MCAL_GPIO_Init>

	/*
	 * Initialize ALL PINS with zero idle state
	 */
	MCAL_GPIO_WritePin(MOTOR1_PORT,MOTOR1_PIN1,PIN_LOW);
 80001f2:	2200      	movs	r2, #0
 80001f4:	2104      	movs	r1, #4
 80001f6:	4816      	ldr	r0, [pc, #88]	; (8000250 <Dc_Motors_Init+0xe0>)
 80001f8:	f000 fde2 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR1_PORT,MOTOR1_PIN2,PIN_LOW);
 80001fc:	2200      	movs	r2, #0
 80001fe:	2105      	movs	r1, #5
 8000200:	4813      	ldr	r0, [pc, #76]	; (8000250 <Dc_Motors_Init+0xe0>)
 8000202:	f000 fddd 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR2_PORT,MOTOR2_PIN1,PIN_LOW);
 8000206:	2200      	movs	r2, #0
 8000208:	2106      	movs	r1, #6
 800020a:	4811      	ldr	r0, [pc, #68]	; (8000250 <Dc_Motors_Init+0xe0>)
 800020c:	f000 fdd8 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR2_PORT,MOTOR2_PIN2,PIN_LOW);
 8000210:	2200      	movs	r2, #0
 8000212:	2107      	movs	r1, #7
 8000214:	480e      	ldr	r0, [pc, #56]	; (8000250 <Dc_Motors_Init+0xe0>)
 8000216:	f000 fdd3 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR3_PORT,MOTOR3_PIN1,PIN_LOW);
 800021a:	2200      	movs	r2, #0
 800021c:	2100      	movs	r1, #0
 800021e:	480d      	ldr	r0, [pc, #52]	; (8000254 <Dc_Motors_Init+0xe4>)
 8000220:	f000 fdce 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR3_PORT,MOTOR3_PIN2,PIN_LOW);
 8000224:	2200      	movs	r2, #0
 8000226:	2101      	movs	r1, #1
 8000228:	480a      	ldr	r0, [pc, #40]	; (8000254 <Dc_Motors_Init+0xe4>)
 800022a:	f000 fdc9 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR4_PORT,MOTOR4_PIN1,PIN_LOW);
 800022e:	2200      	movs	r2, #0
 8000230:	210d      	movs	r1, #13
 8000232:	4808      	ldr	r0, [pc, #32]	; (8000254 <Dc_Motors_Init+0xe4>)
 8000234:	f000 fdc4 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR4_PORT,MOTOR4_PIN2,PIN_LOW);
 8000238:	2200      	movs	r2, #0
 800023a:	210e      	movs	r1, #14
 800023c:	4805      	ldr	r0, [pc, #20]	; (8000254 <Dc_Motors_Init+0xe4>)
 800023e:	f000 fdbf 	bl	8000dc0 <MCAL_GPIO_WritePin>

}
 8000242:	bf00      	nop
 8000244:	3708      	adds	r7, #8
 8000246:	46bd      	mov	sp, r7
 8000248:	bd80      	pop	{r7, pc}
 800024a:	bf00      	nop
 800024c:	080011e4 	.word	0x080011e4
 8000250:	40010800 	.word	0x40010800
 8000254:	40010c00 	.word	0x40010c00

08000258 <DC_Motor_Move_Stop>:
void DC_Motor_Move_Stop(Motor_Number Motor,Motor_State State){
 8000258:	b580      	push	{r7, lr}
 800025a:	b082      	sub	sp, #8
 800025c:	af00      	add	r7, sp, #0
 800025e:	4603      	mov	r3, r0
 8000260:	460a      	mov	r2, r1
 8000262:	71fb      	strb	r3, [r7, #7]
 8000264:	4613      	mov	r3, r2
 8000266:	71bb      	strb	r3, [r7, #6]
	switch(Motor){
 8000268:	79fb      	ldrb	r3, [r7, #7]
 800026a:	2b03      	cmp	r3, #3
 800026c:	f200 80b4 	bhi.w	80003d8 <DC_Motor_Move_Stop+0x180>
 8000270:	a201      	add	r2, pc, #4	; (adr r2, 8000278 <DC_Motor_Move_Stop+0x20>)
 8000272:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000276:	bf00      	nop
 8000278:	08000289 	.word	0x08000289
 800027c:	080002dd 	.word	0x080002dd
 8000280:	08000331 	.word	0x08000331
 8000284:	08000385 	.word	0x08000385
	case M1:
	{
		switch(State){
 8000288:	79bb      	ldrb	r3, [r7, #6]
 800028a:	2b01      	cmp	r3, #1
 800028c:	d00f      	beq.n	80002ae <DC_Motor_Move_Stop+0x56>
 800028e:	2b02      	cmp	r3, #2
 8000290:	d018      	beq.n	80002c4 <DC_Motor_Move_Stop+0x6c>
 8000292:	2b00      	cmp	r3, #0
 8000294:	d000      	beq.n	8000298 <DC_Motor_Move_Stop+0x40>
			MCAL_GPIO_WritePin(MOTOR1_PORT,MOTOR1_PIN1,PIN_LOW);
			MCAL_GPIO_WritePin(MOTOR1_PORT,MOTOR1_PIN2,PIN_HIGH);
			break;
		}
		}
		break;
 8000296:	e09f      	b.n	80003d8 <DC_Motor_Move_Stop+0x180>
			MCAL_GPIO_WritePin(MOTOR1_PORT,MOTOR1_PIN1,PIN_LOW);
 8000298:	2200      	movs	r2, #0
 800029a:	2104      	movs	r1, #4
 800029c:	4850      	ldr	r0, [pc, #320]	; (80003e0 <DC_Motor_Move_Stop+0x188>)
 800029e:	f000 fd8f 	bl	8000dc0 <MCAL_GPIO_WritePin>
			MCAL_GPIO_WritePin(MOTOR1_PORT,MOTOR1_PIN2,PIN_LOW);
 80002a2:	2200      	movs	r2, #0
 80002a4:	2105      	movs	r1, #5
 80002a6:	484e      	ldr	r0, [pc, #312]	; (80003e0 <DC_Motor_Move_Stop+0x188>)
 80002a8:	f000 fd8a 	bl	8000dc0 <MCAL_GPIO_WritePin>
			break;
 80002ac:	e015      	b.n	80002da <DC_Motor_Move_Stop+0x82>
			MCAL_GPIO_WritePin(MOTOR1_PORT,MOTOR1_PIN1,PIN_HIGH);
 80002ae:	2201      	movs	r2, #1
 80002b0:	2104      	movs	r1, #4
 80002b2:	484b      	ldr	r0, [pc, #300]	; (80003e0 <DC_Motor_Move_Stop+0x188>)
 80002b4:	f000 fd84 	bl	8000dc0 <MCAL_GPIO_WritePin>
			MCAL_GPIO_WritePin(MOTOR1_PORT,MOTOR1_PIN2,PIN_LOW);
 80002b8:	2200      	movs	r2, #0
 80002ba:	2105      	movs	r1, #5
 80002bc:	4848      	ldr	r0, [pc, #288]	; (80003e0 <DC_Motor_Move_Stop+0x188>)
 80002be:	f000 fd7f 	bl	8000dc0 <MCAL_GPIO_WritePin>
			break;
 80002c2:	e00a      	b.n	80002da <DC_Motor_Move_Stop+0x82>
			MCAL_GPIO_WritePin(MOTOR1_PORT,MOTOR1_PIN1,PIN_LOW);
 80002c4:	2200      	movs	r2, #0
 80002c6:	2104      	movs	r1, #4
 80002c8:	4845      	ldr	r0, [pc, #276]	; (80003e0 <DC_Motor_Move_Stop+0x188>)
 80002ca:	f000 fd79 	bl	8000dc0 <MCAL_GPIO_WritePin>
			MCAL_GPIO_WritePin(MOTOR1_PORT,MOTOR1_PIN2,PIN_HIGH);
 80002ce:	2201      	movs	r2, #1
 80002d0:	2105      	movs	r1, #5
 80002d2:	4843      	ldr	r0, [pc, #268]	; (80003e0 <DC_Motor_Move_Stop+0x188>)
 80002d4:	f000 fd74 	bl	8000dc0 <MCAL_GPIO_WritePin>
			break;
 80002d8:	bf00      	nop
		break;
 80002da:	e07d      	b.n	80003d8 <DC_Motor_Move_Stop+0x180>
	}
	case M2:
	{
		switch(State){
 80002dc:	79bb      	ldrb	r3, [r7, #6]
 80002de:	2b01      	cmp	r3, #1
 80002e0:	d00f      	beq.n	8000302 <DC_Motor_Move_Stop+0xaa>
 80002e2:	2b02      	cmp	r3, #2
 80002e4:	d018      	beq.n	8000318 <DC_Motor_Move_Stop+0xc0>
 80002e6:	2b00      	cmp	r3, #0
 80002e8:	d000      	beq.n	80002ec <DC_Motor_Move_Stop+0x94>
			MCAL_GPIO_WritePin(MOTOR2_PORT,MOTOR2_PIN1,PIN_LOW);
			MCAL_GPIO_WritePin(MOTOR2_PORT,MOTOR2_PIN2,PIN_HIGH);
			break;
		}
		}
		break;
 80002ea:	e075      	b.n	80003d8 <DC_Motor_Move_Stop+0x180>
			MCAL_GPIO_WritePin(MOTOR2_PORT,MOTOR2_PIN1,PIN_LOW);
 80002ec:	2200      	movs	r2, #0
 80002ee:	2106      	movs	r1, #6
 80002f0:	483b      	ldr	r0, [pc, #236]	; (80003e0 <DC_Motor_Move_Stop+0x188>)
 80002f2:	f000 fd65 	bl	8000dc0 <MCAL_GPIO_WritePin>
			MCAL_GPIO_WritePin(MOTOR2_PORT,MOTOR2_PIN2,PIN_LOW);
 80002f6:	2200      	movs	r2, #0
 80002f8:	2107      	movs	r1, #7
 80002fa:	4839      	ldr	r0, [pc, #228]	; (80003e0 <DC_Motor_Move_Stop+0x188>)
 80002fc:	f000 fd60 	bl	8000dc0 <MCAL_GPIO_WritePin>
			break;
 8000300:	e015      	b.n	800032e <DC_Motor_Move_Stop+0xd6>
			MCAL_GPIO_WritePin(MOTOR2_PORT,MOTOR2_PIN1,PIN_HIGH);
 8000302:	2201      	movs	r2, #1
 8000304:	2106      	movs	r1, #6
 8000306:	4836      	ldr	r0, [pc, #216]	; (80003e0 <DC_Motor_Move_Stop+0x188>)
 8000308:	f000 fd5a 	bl	8000dc0 <MCAL_GPIO_WritePin>
			MCAL_GPIO_WritePin(MOTOR2_PORT,MOTOR2_PIN2,PIN_LOW);
 800030c:	2200      	movs	r2, #0
 800030e:	2107      	movs	r1, #7
 8000310:	4833      	ldr	r0, [pc, #204]	; (80003e0 <DC_Motor_Move_Stop+0x188>)
 8000312:	f000 fd55 	bl	8000dc0 <MCAL_GPIO_WritePin>
			break;
 8000316:	e00a      	b.n	800032e <DC_Motor_Move_Stop+0xd6>
			MCAL_GPIO_WritePin(MOTOR2_PORT,MOTOR2_PIN1,PIN_LOW);
 8000318:	2200      	movs	r2, #0
 800031a:	2106      	movs	r1, #6
 800031c:	4830      	ldr	r0, [pc, #192]	; (80003e0 <DC_Motor_Move_Stop+0x188>)
 800031e:	f000 fd4f 	bl	8000dc0 <MCAL_GPIO_WritePin>
			MCAL_GPIO_WritePin(MOTOR2_PORT,MOTOR2_PIN2,PIN_HIGH);
 8000322:	2201      	movs	r2, #1
 8000324:	2107      	movs	r1, #7
 8000326:	482e      	ldr	r0, [pc, #184]	; (80003e0 <DC_Motor_Move_Stop+0x188>)
 8000328:	f000 fd4a 	bl	8000dc0 <MCAL_GPIO_WritePin>
			break;
 800032c:	bf00      	nop
		break;
 800032e:	e053      	b.n	80003d8 <DC_Motor_Move_Stop+0x180>
	}
	case M3:
	{
		switch(State){
 8000330:	79bb      	ldrb	r3, [r7, #6]
 8000332:	2b01      	cmp	r3, #1
 8000334:	d00f      	beq.n	8000356 <DC_Motor_Move_Stop+0xfe>
 8000336:	2b02      	cmp	r3, #2
 8000338:	d018      	beq.n	800036c <DC_Motor_Move_Stop+0x114>
 800033a:	2b00      	cmp	r3, #0
 800033c:	d000      	beq.n	8000340 <DC_Motor_Move_Stop+0xe8>
			MCAL_GPIO_WritePin(MOTOR3_PORT,MOTOR3_PIN1,PIN_LOW);
			MCAL_GPIO_WritePin(MOTOR3_PORT,MOTOR3_PIN2,PIN_HIGH);
			break;
		}
		}
		break;
 800033e:	e04b      	b.n	80003d8 <DC_Motor_Move_Stop+0x180>
			MCAL_GPIO_WritePin(MOTOR3_PORT,MOTOR3_PIN1,PIN_LOW);
 8000340:	2200      	movs	r2, #0
 8000342:	2100      	movs	r1, #0
 8000344:	4827      	ldr	r0, [pc, #156]	; (80003e4 <DC_Motor_Move_Stop+0x18c>)
 8000346:	f000 fd3b 	bl	8000dc0 <MCAL_GPIO_WritePin>
			MCAL_GPIO_WritePin(MOTOR3_PORT,MOTOR3_PIN2,PIN_LOW);
 800034a:	2200      	movs	r2, #0
 800034c:	2101      	movs	r1, #1
 800034e:	4825      	ldr	r0, [pc, #148]	; (80003e4 <DC_Motor_Move_Stop+0x18c>)
 8000350:	f000 fd36 	bl	8000dc0 <MCAL_GPIO_WritePin>
			break;
 8000354:	e015      	b.n	8000382 <DC_Motor_Move_Stop+0x12a>
			MCAL_GPIO_WritePin(MOTOR3_PORT,MOTOR3_PIN1,PIN_HIGH);
 8000356:	2201      	movs	r2, #1
 8000358:	2100      	movs	r1, #0
 800035a:	4822      	ldr	r0, [pc, #136]	; (80003e4 <DC_Motor_Move_Stop+0x18c>)
 800035c:	f000 fd30 	bl	8000dc0 <MCAL_GPIO_WritePin>
			MCAL_GPIO_WritePin(MOTOR3_PORT,MOTOR3_PIN2,PIN_LOW);
 8000360:	2200      	movs	r2, #0
 8000362:	2101      	movs	r1, #1
 8000364:	481f      	ldr	r0, [pc, #124]	; (80003e4 <DC_Motor_Move_Stop+0x18c>)
 8000366:	f000 fd2b 	bl	8000dc0 <MCAL_GPIO_WritePin>
			break;
 800036a:	e00a      	b.n	8000382 <DC_Motor_Move_Stop+0x12a>
			MCAL_GPIO_WritePin(MOTOR3_PORT,MOTOR3_PIN1,PIN_LOW);
 800036c:	2200      	movs	r2, #0
 800036e:	2100      	movs	r1, #0
 8000370:	481c      	ldr	r0, [pc, #112]	; (80003e4 <DC_Motor_Move_Stop+0x18c>)
 8000372:	f000 fd25 	bl	8000dc0 <MCAL_GPIO_WritePin>
			MCAL_GPIO_WritePin(MOTOR3_PORT,MOTOR3_PIN2,PIN_HIGH);
 8000376:	2201      	movs	r2, #1
 8000378:	2101      	movs	r1, #1
 800037a:	481a      	ldr	r0, [pc, #104]	; (80003e4 <DC_Motor_Move_Stop+0x18c>)
 800037c:	f000 fd20 	bl	8000dc0 <MCAL_GPIO_WritePin>
			break;
 8000380:	bf00      	nop
		break;
 8000382:	e029      	b.n	80003d8 <DC_Motor_Move_Stop+0x180>
	}
	case M4:
	{
		switch(State){
 8000384:	79bb      	ldrb	r3, [r7, #6]
 8000386:	2b01      	cmp	r3, #1
 8000388:	d00f      	beq.n	80003aa <DC_Motor_Move_Stop+0x152>
 800038a:	2b02      	cmp	r3, #2
 800038c:	d018      	beq.n	80003c0 <DC_Motor_Move_Stop+0x168>
 800038e:	2b00      	cmp	r3, #0
 8000390:	d000      	beq.n	8000394 <DC_Motor_Move_Stop+0x13c>
			MCAL_GPIO_WritePin(MOTOR4_PORT,MOTOR4_PIN1,PIN_LOW);
			MCAL_GPIO_WritePin(MOTOR4_PORT,MOTOR4_PIN2,PIN_HIGH);
			break;
		}
		}
		break;
 8000392:	e020      	b.n	80003d6 <DC_Motor_Move_Stop+0x17e>
			MCAL_GPIO_WritePin(MOTOR4_PORT,MOTOR4_PIN1,PIN_LOW);
 8000394:	2200      	movs	r2, #0
 8000396:	210d      	movs	r1, #13
 8000398:	4812      	ldr	r0, [pc, #72]	; (80003e4 <DC_Motor_Move_Stop+0x18c>)
 800039a:	f000 fd11 	bl	8000dc0 <MCAL_GPIO_WritePin>
			MCAL_GPIO_WritePin(MOTOR4_PORT,MOTOR4_PIN2,PIN_LOW);
 800039e:	2200      	movs	r2, #0
 80003a0:	210e      	movs	r1, #14
 80003a2:	4810      	ldr	r0, [pc, #64]	; (80003e4 <DC_Motor_Move_Stop+0x18c>)
 80003a4:	f000 fd0c 	bl	8000dc0 <MCAL_GPIO_WritePin>
			break;
 80003a8:	e015      	b.n	80003d6 <DC_Motor_Move_Stop+0x17e>
			MCAL_GPIO_WritePin(MOTOR4_PORT,MOTOR4_PIN1,PIN_HIGH);
 80003aa:	2201      	movs	r2, #1
 80003ac:	210d      	movs	r1, #13
 80003ae:	480d      	ldr	r0, [pc, #52]	; (80003e4 <DC_Motor_Move_Stop+0x18c>)
 80003b0:	f000 fd06 	bl	8000dc0 <MCAL_GPIO_WritePin>
			MCAL_GPIO_WritePin(MOTOR4_PORT,MOTOR4_PIN2,PIN_LOW);
 80003b4:	2200      	movs	r2, #0
 80003b6:	210e      	movs	r1, #14
 80003b8:	480a      	ldr	r0, [pc, #40]	; (80003e4 <DC_Motor_Move_Stop+0x18c>)
 80003ba:	f000 fd01 	bl	8000dc0 <MCAL_GPIO_WritePin>
			break;
 80003be:	e00a      	b.n	80003d6 <DC_Motor_Move_Stop+0x17e>
			MCAL_GPIO_WritePin(MOTOR4_PORT,MOTOR4_PIN1,PIN_LOW);
 80003c0:	2200      	movs	r2, #0
 80003c2:	210d      	movs	r1, #13
 80003c4:	4807      	ldr	r0, [pc, #28]	; (80003e4 <DC_Motor_Move_Stop+0x18c>)
 80003c6:	f000 fcfb 	bl	8000dc0 <MCAL_GPIO_WritePin>
			MCAL_GPIO_WritePin(MOTOR4_PORT,MOTOR4_PIN2,PIN_HIGH);
 80003ca:	2201      	movs	r2, #1
 80003cc:	210e      	movs	r1, #14
 80003ce:	4805      	ldr	r0, [pc, #20]	; (80003e4 <DC_Motor_Move_Stop+0x18c>)
 80003d0:	f000 fcf6 	bl	8000dc0 <MCAL_GPIO_WritePin>
			break;
 80003d4:	bf00      	nop
		break;
 80003d6:	bf00      	nop
	}
	}
}
 80003d8:	bf00      	nop
 80003da:	3708      	adds	r7, #8
 80003dc:	46bd      	mov	sp, r7
 80003de:	bd80      	pop	{r7, pc}
 80003e0:	40010800 	.word	0x40010800
 80003e4:	40010c00 	.word	0x40010c00

080003e8 <Stop_CAR>:
void Stop_CAR(void){
 80003e8:	b580      	push	{r7, lr}
 80003ea:	af00      	add	r7, sp, #0
	MCAL_GPIO_WritePin(MOTOR1_PORT,MOTOR1_PIN1,PIN_LOW);
 80003ec:	2200      	movs	r2, #0
 80003ee:	2104      	movs	r1, #4
 80003f0:	4813      	ldr	r0, [pc, #76]	; (8000440 <Stop_CAR+0x58>)
 80003f2:	f000 fce5 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR1_PORT,MOTOR1_PIN2,PIN_LOW);
 80003f6:	2200      	movs	r2, #0
 80003f8:	2105      	movs	r1, #5
 80003fa:	4811      	ldr	r0, [pc, #68]	; (8000440 <Stop_CAR+0x58>)
 80003fc:	f000 fce0 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR2_PORT,MOTOR2_PIN1,PIN_LOW);
 8000400:	2200      	movs	r2, #0
 8000402:	2106      	movs	r1, #6
 8000404:	480e      	ldr	r0, [pc, #56]	; (8000440 <Stop_CAR+0x58>)
 8000406:	f000 fcdb 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR2_PORT,MOTOR2_PIN2,PIN_LOW);
 800040a:	2200      	movs	r2, #0
 800040c:	2107      	movs	r1, #7
 800040e:	480c      	ldr	r0, [pc, #48]	; (8000440 <Stop_CAR+0x58>)
 8000410:	f000 fcd6 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR3_PORT,MOTOR3_PIN1,PIN_LOW);
 8000414:	2200      	movs	r2, #0
 8000416:	2100      	movs	r1, #0
 8000418:	480a      	ldr	r0, [pc, #40]	; (8000444 <Stop_CAR+0x5c>)
 800041a:	f000 fcd1 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR3_PORT,MOTOR3_PIN2,PIN_LOW);
 800041e:	2200      	movs	r2, #0
 8000420:	2101      	movs	r1, #1
 8000422:	4808      	ldr	r0, [pc, #32]	; (8000444 <Stop_CAR+0x5c>)
 8000424:	f000 fccc 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR4_PORT,MOTOR4_PIN1,PIN_LOW);
 8000428:	2200      	movs	r2, #0
 800042a:	210d      	movs	r1, #13
 800042c:	4805      	ldr	r0, [pc, #20]	; (8000444 <Stop_CAR+0x5c>)
 800042e:	f000 fcc7 	bl	8000dc0 <MCAL_GPIO_WritePin>
	MCAL_GPIO_WritePin(MOTOR4_PORT,MOTOR4_PIN2,PIN_LOW);
 8000432:	2200      	movs	r2, #0
 8000434:	210e      	movs	r1, #14
 8000436:	4803      	ldr	r0, [pc, #12]	; (8000444 <Stop_CAR+0x5c>)
 8000438:	f000 fcc2 	bl	8000dc0 <MCAL_GPIO_WritePin>
}
 800043c:	bf00      	nop
 800043e:	bd80      	pop	{r7, pc}
 8000440:	40010800 	.word	0x40010800
 8000444:	40010c00 	.word	0x40010c00

08000448 <HAL_HC05_Init>:
 *  Created on: Dec 5, 2023
 *      Author: mohamed salah
 */
#include "HC-05.h"
uint16 Received_char=0;
void HAL_HC05_Init(){
 8000448:	b590      	push	{r4, r7, lr}
 800044a:	b085      	sub	sp, #20
 800044c:	af00      	add	r7, sp, #0
	ENABLE_CLOCK_GPIOA();
 800044e:	4b10      	ldr	r3, [pc, #64]	; (8000490 <HAL_HC05_Init+0x48>)
 8000450:	699b      	ldr	r3, [r3, #24]
 8000452:	4a0f      	ldr	r2, [pc, #60]	; (8000490 <HAL_HC05_Init+0x48>)
 8000454:	f043 0304 	orr.w	r3, r3, #4
 8000458:	6193      	str	r3, [r2, #24]
	ENABLE_CLOCK_AFIO();
 800045a:	4b0d      	ldr	r3, [pc, #52]	; (8000490 <HAL_HC05_Init+0x48>)
 800045c:	699b      	ldr	r3, [r3, #24]
 800045e:	4a0c      	ldr	r2, [pc, #48]	; (8000490 <HAL_HC05_Init+0x48>)
 8000460:	f043 0301 	orr.w	r3, r3, #1
 8000464:	6193      	str	r3, [r2, #24]
	ENABLE_CLOCK_GPIOB();
 8000466:	4b0a      	ldr	r3, [pc, #40]	; (8000490 <HAL_HC05_Init+0x48>)
 8000468:	699b      	ldr	r3, [r3, #24]
 800046a:	4a09      	ldr	r2, [pc, #36]	; (8000490 <HAL_HC05_Init+0x48>)
 800046c:	f043 0308 	orr.w	r3, r3, #8
 8000470:	6193      	str	r3, [r2, #24]
	USART_Pin_Config USART_CON={Eight_Bit,One_Bit,Both,Default_Baud,Enable,Interrupt_RXNEIE_Enable,none,NONE,HAL_HC05_RecieveChar};
 8000472:	4b08      	ldr	r3, [pc, #32]	; (8000494 <HAL_HC05_Init+0x4c>)
 8000474:	463c      	mov	r4, r7
 8000476:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000478:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	MCAL_USART_Init(Bluetooth_Uart, &USART_CON);
 800047c:	463b      	mov	r3, r7
 800047e:	4619      	mov	r1, r3
 8000480:	4805      	ldr	r0, [pc, #20]	; (8000498 <HAL_HC05_Init+0x50>)
 8000482:	f000 f819 	bl	80004b8 <MCAL_USART_Init>

}
 8000486:	bf00      	nop
 8000488:	3714      	adds	r7, #20
 800048a:	46bd      	mov	sp, r7
 800048c:	bd90      	pop	{r4, r7, pc}
 800048e:	bf00      	nop
 8000490:	40021000 	.word	0x40021000
 8000494:	080011e8 	.word	0x080011e8
 8000498:	40004400 	.word	0x40004400

0800049c <HAL_HC05_RecieveChar>:
void HAL_HC05_RecieveChar(void){
 800049c:	b580      	push	{r7, lr}
 800049e:	af00      	add	r7, sp, #0
	MCAL_USART_ReceiveData(Bluetooth_Uart,&Received_char,Enable);
 80004a0:	2201      	movs	r2, #1
 80004a2:	4903      	ldr	r1, [pc, #12]	; (80004b0 <HAL_HC05_RecieveChar+0x14>)
 80004a4:	4803      	ldr	r0, [pc, #12]	; (80004b4 <HAL_HC05_RecieveChar+0x18>)
 80004a6:	f000 f97d 	bl	80007a4 <MCAL_USART_ReceiveData>
}
 80004aa:	bf00      	nop
 80004ac:	bd80      	pop	{r7, pc}
 80004ae:	bf00      	nop
 80004b0:	20000034 	.word	0x20000034
 80004b4:	40004400 	.word	0x40004400

080004b8 <MCAL_USART_Init>:

#include "Stm32f103C6_Driver_USART.h"
USART_Pin_Config Global_Config;
uint8 AHB_PRE_SCALER[16U]={0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8};
uint8 APB_PRE_SCALER[8U]={0,0,0,0,1,2,3,4};
void MCAL_USART_Init(USART_Reg* USARTx,USART_Pin_Config* Pin_Config){
 80004b8:	b590      	push	{r4, r7, lr}
 80004ba:	b089      	sub	sp, #36	; 0x24
 80004bc:	af00      	add	r7, sp, #0
 80004be:	6078      	str	r0, [r7, #4]
 80004c0:	6039      	str	r1, [r7, #0]
	Global_Config = *Pin_Config;
 80004c2:	4a99      	ldr	r2, [pc, #612]	; (8000728 <MCAL_USART_Init+0x270>)
 80004c4:	683b      	ldr	r3, [r7, #0]
 80004c6:	4614      	mov	r4, r2
 80004c8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80004ca:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	vuint32 USARTDIV_MUL100 ,DIV_Mantissa,DIV_Fraction,DIV_Mantissa_MUL100,BRR;
	vuint32 pclk;
	//Enable Clock For Uartx
	if(USARTx == USART1){
 80004ce:	687b      	ldr	r3, [r7, #4]
 80004d0:	4a96      	ldr	r2, [pc, #600]	; (800072c <MCAL_USART_Init+0x274>)
 80004d2:	4293      	cmp	r3, r2
 80004d4:	d106      	bne.n	80004e4 <MCAL_USART_Init+0x2c>
		ENABLE_CLOCK_USART1();
 80004d6:	4b96      	ldr	r3, [pc, #600]	; (8000730 <MCAL_USART_Init+0x278>)
 80004d8:	699b      	ldr	r3, [r3, #24]
 80004da:	4a95      	ldr	r2, [pc, #596]	; (8000730 <MCAL_USART_Init+0x278>)
 80004dc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80004e0:	6193      	str	r3, [r2, #24]
 80004e2:	e014      	b.n	800050e <MCAL_USART_Init+0x56>
	}else if(USARTx == USART2){
 80004e4:	687b      	ldr	r3, [r7, #4]
 80004e6:	4a93      	ldr	r2, [pc, #588]	; (8000734 <MCAL_USART_Init+0x27c>)
 80004e8:	4293      	cmp	r3, r2
 80004ea:	d106      	bne.n	80004fa <MCAL_USART_Init+0x42>
		ENABLE_CLOCK_USART2();
 80004ec:	4b90      	ldr	r3, [pc, #576]	; (8000730 <MCAL_USART_Init+0x278>)
 80004ee:	69db      	ldr	r3, [r3, #28]
 80004f0:	4a8f      	ldr	r2, [pc, #572]	; (8000730 <MCAL_USART_Init+0x278>)
 80004f2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80004f6:	61d3      	str	r3, [r2, #28]
 80004f8:	e009      	b.n	800050e <MCAL_USART_Init+0x56>
	}else if(USARTx == USART3){
 80004fa:	687b      	ldr	r3, [r7, #4]
 80004fc:	4a8e      	ldr	r2, [pc, #568]	; (8000738 <MCAL_USART_Init+0x280>)
 80004fe:	4293      	cmp	r3, r2
 8000500:	d105      	bne.n	800050e <MCAL_USART_Init+0x56>
		ENABLE_CLOCK_USART3();
 8000502:	4b8b      	ldr	r3, [pc, #556]	; (8000730 <MCAL_USART_Init+0x278>)
 8000504:	69db      	ldr	r3, [r3, #28]
 8000506:	4a8a      	ldr	r2, [pc, #552]	; (8000730 <MCAL_USART_Init+0x278>)
 8000508:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800050c:	61d3      	str	r3, [r2, #28]
	}

	//Enable the USART by writing the UE bit in USART_CR1 register to 1.
	USARTx->USART_CR1.BIT_Name.UE=USART_Enable;
 800050e:	687a      	ldr	r2, [r7, #4]
 8000510:	8993      	ldrh	r3, [r2, #12]
 8000512:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000516:	8193      	strh	r3, [r2, #12]
	//Configure word length
	/*M: Word length
		This bit determines the word length. It is set or cleared by software.
		0: 1 Start bit, 8 Data bits, n Stop bit
		1: 1 Start bit, 9 Data bits, n Stop bit*/
	USARTx->USART_CR1.BIT_Name.M=Pin_Config->Length;
 8000518:	683b      	ldr	r3, [r7, #0]
 800051a:	781b      	ldrb	r3, [r3, #0]
 800051c:	f003 0301 	and.w	r3, r3, #1
 8000520:	b2d9      	uxtb	r1, r3
 8000522:	687a      	ldr	r2, [r7, #4]
 8000524:	8993      	ldrh	r3, [r2, #12]
 8000526:	f361 330c 	bfi	r3, r1, #12, #1
 800052a:	8193      	strh	r3, [r2, #12]
	//Configure Stop Bits
	USARTx->USART_CR2.BIT_Name.STOP = Pin_Config->Stop;
 800052c:	683b      	ldr	r3, [r7, #0]
 800052e:	785b      	ldrb	r3, [r3, #1]
 8000530:	f003 0303 	and.w	r3, r3, #3
 8000534:	b2d9      	uxtb	r1, r3
 8000536:	687a      	ldr	r2, [r7, #4]
 8000538:	8a13      	ldrh	r3, [r2, #16]
 800053a:	f361 330d 	bfi	r3, r1, #12, #2
 800053e:	8213      	strh	r3, [r2, #16]
	control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit
	if M=0) and parity is checked on the received data. This bit is set and cleared by software.
	Once it is set, PCE is active after the current byte (in reception and in transmission).
	0: Parity control disabled
	1: Parity control enabled*/
	switch(Pin_Config->Parity){
 8000540:	683b      	ldr	r3, [r7, #0]
 8000542:	7a9b      	ldrb	r3, [r3, #10]
 8000544:	2b01      	cmp	r3, #1
 8000546:	d00e      	beq.n	8000566 <MCAL_USART_Init+0xae>
 8000548:	2b02      	cmp	r3, #2
 800054a:	d017      	beq.n	800057c <MCAL_USART_Init+0xc4>
 800054c:	2b00      	cmp	r3, #0
 800054e:	d11b      	bne.n	8000588 <MCAL_USART_Init+0xd0>
	case  even:
		USARTx->USART_CR1.BIT_Name.PCE=Parity_Enable;
 8000550:	687a      	ldr	r2, [r7, #4]
 8000552:	8993      	ldrh	r3, [r2, #12]
 8000554:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000558:	8193      	strh	r3, [r2, #12]
		USARTx->USART_CR1.BIT_Name.PS = even;
 800055a:	687a      	ldr	r2, [r7, #4]
 800055c:	8993      	ldrh	r3, [r2, #12]
 800055e:	f36f 2349 	bfc	r3, #9, #1
 8000562:	8193      	strh	r3, [r2, #12]
		break;
 8000564:	e010      	b.n	8000588 <MCAL_USART_Init+0xd0>
	case  odd:
		USARTx->USART_CR1.BIT_Name.PCE=Parity_Enable;
 8000566:	687a      	ldr	r2, [r7, #4]
 8000568:	8993      	ldrh	r3, [r2, #12]
 800056a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800056e:	8193      	strh	r3, [r2, #12]
		USARTx->USART_CR1.BIT_Name.PS = odd;
 8000570:	687a      	ldr	r2, [r7, #4]
 8000572:	8993      	ldrh	r3, [r2, #12]
 8000574:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000578:	8193      	strh	r3, [r2, #12]
		break;
 800057a:	e005      	b.n	8000588 <MCAL_USART_Init+0xd0>
	case  none:
		USARTx->USART_CR1.BIT_Name.PCE=Parity_Disable;
 800057c:	687a      	ldr	r2, [r7, #4]
 800057e:	8993      	ldrh	r3, [r2, #12]
 8000580:	f36f 238a 	bfc	r3, #10, #1
 8000584:	8193      	strh	r3, [r2, #12]
		break;
 8000586:	bf00      	nop
	}
	//Configure transmit and receive enable
	if(Pin_Config->Mode == Transmitter || Pin_Config->Mode == Both){
 8000588:	683b      	ldr	r3, [r7, #0]
 800058a:	789b      	ldrb	r3, [r3, #2]
 800058c:	2b00      	cmp	r3, #0
 800058e:	d003      	beq.n	8000598 <MCAL_USART_Init+0xe0>
 8000590:	683b      	ldr	r3, [r7, #0]
 8000592:	789b      	ldrb	r3, [r3, #2]
 8000594:	2b02      	cmp	r3, #2
 8000596:	d104      	bne.n	80005a2 <MCAL_USART_Init+0xea>
		USARTx->USART_CR1.BIT_Name.TE = Transmitt_Enable;
 8000598:	687a      	ldr	r2, [r7, #4]
 800059a:	8993      	ldrh	r3, [r2, #12]
 800059c:	f043 0308 	orr.w	r3, r3, #8
 80005a0:	8193      	strh	r3, [r2, #12]
	}
	if(Pin_Config->Mode == Recevier || Pin_Config->Mode == Both){
 80005a2:	683b      	ldr	r3, [r7, #0]
 80005a4:	789b      	ldrb	r3, [r3, #2]
 80005a6:	2b01      	cmp	r3, #1
 80005a8:	d003      	beq.n	80005b2 <MCAL_USART_Init+0xfa>
 80005aa:	683b      	ldr	r3, [r7, #0]
 80005ac:	789b      	ldrb	r3, [r3, #2]
 80005ae:	2b02      	cmp	r3, #2
 80005b0:	d104      	bne.n	80005bc <MCAL_USART_Init+0x104>
		USARTx->USART_CR1.BIT_Name.RE = Recevier_Enable;
 80005b2:	687a      	ldr	r2, [r7, #4]
 80005b4:	8993      	ldrh	r3, [r2, #12]
 80005b6:	f043 0304 	orr.w	r3, r3, #4
 80005ba:	8193      	strh	r3, [r2, #12]
	}


	//Hardware control flow
	if(Pin_Config->HW_Flow == CTS_RTS){
 80005bc:	683b      	ldr	r3, [r7, #0]
 80005be:	7adb      	ldrb	r3, [r3, #11]
 80005c0:	2b03      	cmp	r3, #3
 80005c2:	d10a      	bne.n	80005da <MCAL_USART_Init+0x122>
		USARTx->USART_CR3.BIT_Name.CTSE=CTS_ENABLE;
 80005c4:	687a      	ldr	r2, [r7, #4]
 80005c6:	8a93      	ldrh	r3, [r2, #20]
 80005c8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80005cc:	8293      	strh	r3, [r2, #20]
		USARTx->USART_CR3.BIT_Name.RTSE=RTS_ENABLE;
 80005ce:	687a      	ldr	r2, [r7, #4]
 80005d0:	8a93      	ldrh	r3, [r2, #20]
 80005d2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80005d6:	8293      	strh	r3, [r2, #20]
 80005d8:	e01d      	b.n	8000616 <MCAL_USART_Init+0x15e>
	}else if (Pin_Config->HW_Flow == RTS){
 80005da:	683b      	ldr	r3, [r7, #0]
 80005dc:	7adb      	ldrb	r3, [r3, #11]
 80005de:	2b01      	cmp	r3, #1
 80005e0:	d105      	bne.n	80005ee <MCAL_USART_Init+0x136>
		USARTx->USART_CR3.BIT_Name.RTSE=RTS_ENABLE;
 80005e2:	687a      	ldr	r2, [r7, #4]
 80005e4:	8a93      	ldrh	r3, [r2, #20]
 80005e6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80005ea:	8293      	strh	r3, [r2, #20]
 80005ec:	e013      	b.n	8000616 <MCAL_USART_Init+0x15e>
	}else if (Pin_Config->HW_Flow == CTS){
 80005ee:	683b      	ldr	r3, [r7, #0]
 80005f0:	7adb      	ldrb	r3, [r3, #11]
 80005f2:	2b02      	cmp	r3, #2
 80005f4:	d105      	bne.n	8000602 <MCAL_USART_Init+0x14a>
		USARTx->USART_CR3.BIT_Name.CTSE=CTS_ENABLE;
 80005f6:	687a      	ldr	r2, [r7, #4]
 80005f8:	8a93      	ldrh	r3, [r2, #20]
 80005fa:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80005fe:	8293      	strh	r3, [r2, #20]
 8000600:	e009      	b.n	8000616 <MCAL_USART_Init+0x15e>
	}else{
		USARTx->USART_CR3.BIT_Name.CTSE=CTS_DISABLE;
 8000602:	687a      	ldr	r2, [r7, #4]
 8000604:	8a93      	ldrh	r3, [r2, #20]
 8000606:	f36f 2349 	bfc	r3, #9, #1
 800060a:	8293      	strh	r3, [r2, #20]
		USARTx->USART_CR3.BIT_Name.RTSE=RTS_DISABLE;
 800060c:	687a      	ldr	r2, [r7, #4]
 800060e:	8a93      	ldrh	r3, [r2, #20]
 8000610:	f36f 2308 	bfc	r3, #8, #1
 8000614:	8293      	strh	r3, [r2, #20]
	}

	//Configure Baud rate
	if(USARTx == USART1){
 8000616:	687b      	ldr	r3, [r7, #4]
 8000618:	4a44      	ldr	r2, [pc, #272]	; (800072c <MCAL_USART_Init+0x274>)
 800061a:	4293      	cmp	r3, r2
 800061c:	d104      	bne.n	8000628 <MCAL_USART_Init+0x170>
		pclk = Get_APB2_CLK();
 800061e:	f000 fa5b 	bl	8000ad8 <Get_APB2_CLK>
 8000622:	4603      	mov	r3, r0
 8000624:	60bb      	str	r3, [r7, #8]
 8000626:	e003      	b.n	8000630 <MCAL_USART_Init+0x178>
	}else{
		pclk = Get_APB1_CLK();
 8000628:	f000 fa42 	bl	8000ab0 <Get_APB1_CLK>
 800062c:	4603      	mov	r3, r0
 800062e:	60bb      	str	r3, [r7, #8]
	}
	//USARTDIV = DIV_Mantissa + (DIV_Fraction / 16)
	//	USARTx->USART_BRR.ALL_REG= ( pclk,Pin_Config->Baud_Rate);
	USARTDIV_MUL100 = (25UL*pclk) / (4UL*Pin_Config->Baud_Rate);
 8000630:	68ba      	ldr	r2, [r7, #8]
 8000632:	4613      	mov	r3, r2
 8000634:	009b      	lsls	r3, r3, #2
 8000636:	4413      	add	r3, r2
 8000638:	009a      	lsls	r2, r3, #2
 800063a:	441a      	add	r2, r3
 800063c:	683b      	ldr	r3, [r7, #0]
 800063e:	685b      	ldr	r3, [r3, #4]
 8000640:	009b      	lsls	r3, r3, #2
 8000642:	fbb2 f3f3 	udiv	r3, r2, r3
 8000646:	61fb      	str	r3, [r7, #28]

	DIV_Mantissa_MUL100 = (USARTDIV_MUL100/100) * 100;
 8000648:	69fb      	ldr	r3, [r7, #28]
 800064a:	4a3c      	ldr	r2, [pc, #240]	; (800073c <MCAL_USART_Init+0x284>)
 800064c:	fba2 2303 	umull	r2, r3, r2, r3
 8000650:	095b      	lsrs	r3, r3, #5
 8000652:	2264      	movs	r2, #100	; 0x64
 8000654:	fb02 f303 	mul.w	r3, r2, r3
 8000658:	613b      	str	r3, [r7, #16]

	DIV_Mantissa = DIV_Mantissa_MUL100 / 100 ;
 800065a:	693b      	ldr	r3, [r7, #16]
 800065c:	4a37      	ldr	r2, [pc, #220]	; (800073c <MCAL_USART_Init+0x284>)
 800065e:	fba2 2303 	umull	r2, r3, r2, r3
 8000662:	095b      	lsrs	r3, r3, #5
 8000664:	61bb      	str	r3, [r7, #24]

	DIV_Fraction = ((USARTDIV_MUL100-DIV_Mantissa_MUL100)*16)/100;   //USARTDIV_MUL100 = DIV_Mantissa_MUL100 + (16*100*DIV_Fraction)
 8000666:	69fa      	ldr	r2, [r7, #28]
 8000668:	693b      	ldr	r3, [r7, #16]
 800066a:	1ad3      	subs	r3, r2, r3
 800066c:	011b      	lsls	r3, r3, #4
 800066e:	4a33      	ldr	r2, [pc, #204]	; (800073c <MCAL_USART_Init+0x284>)
 8000670:	fba2 2303 	umull	r2, r3, r2, r3
 8000674:	095b      	lsrs	r3, r3, #5
 8000676:	617b      	str	r3, [r7, #20]


	BRR = (DIV_Mantissa << 4 ) | (DIV_Fraction & 0xF) ;
 8000678:	69bb      	ldr	r3, [r7, #24]
 800067a:	011a      	lsls	r2, r3, #4
 800067c:	697b      	ldr	r3, [r7, #20]
 800067e:	f003 030f 	and.w	r3, r3, #15
 8000682:	4313      	orrs	r3, r2
 8000684:	60fb      	str	r3, [r7, #12]

	USARTx->USART_BRR.ALL_REG = BRR;
 8000686:	68fa      	ldr	r2, [r7, #12]
 8000688:	687b      	ldr	r3, [r7, #4]
 800068a:	609a      	str	r2, [r3, #8]




	//IRQ STATUS
	if(Pin_Config->Interrupt == Enable){
 800068c:	683b      	ldr	r3, [r7, #0]
 800068e:	7a1b      	ldrb	r3, [r3, #8]
 8000690:	2b01      	cmp	r3, #1
 8000692:	d157      	bne.n	8000744 <MCAL_USART_Init+0x28c>
		switch(Pin_Config->Interrupt_Type){
 8000694:	683b      	ldr	r3, [r7, #0]
 8000696:	7a5b      	ldrb	r3, [r3, #9]
 8000698:	2b03      	cmp	r3, #3
 800069a:	d823      	bhi.n	80006e4 <MCAL_USART_Init+0x22c>
 800069c:	a201      	add	r2, pc, #4	; (adr r2, 80006a4 <MCAL_USART_Init+0x1ec>)
 800069e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80006a2:	bf00      	nop
 80006a4:	080006b5 	.word	0x080006b5
 80006a8:	080006c1 	.word	0x080006c1
 80006ac:	080006cd 	.word	0x080006cd
 80006b0:	080006d9 	.word	0x080006d9
		case Interrupt_RXNEIE_Enable:
			USARTx->USART_CR1.BIT_Name.RXNEIE=USART_Interrupt_Enable;
 80006b4:	687a      	ldr	r2, [r7, #4]
 80006b6:	8993      	ldrh	r3, [r2, #12]
 80006b8:	f043 0320 	orr.w	r3, r3, #32
 80006bc:	8193      	strh	r3, [r2, #12]
			break;
 80006be:	e011      	b.n	80006e4 <MCAL_USART_Init+0x22c>
		case Interrupt_TXE_Enable:
			USARTx->USART_CR1.BIT_Name.TXEIE=USART_Interrupt_Enable;
 80006c0:	687a      	ldr	r2, [r7, #4]
 80006c2:	8993      	ldrh	r3, [r2, #12]
 80006c4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80006c8:	8193      	strh	r3, [r2, #12]
			break;
 80006ca:	e00b      	b.n	80006e4 <MCAL_USART_Init+0x22c>
		case Interrupt_PE_Enable:
			USARTx->USART_CR1.BIT_Name.PEIE=USART_Interrupt_Enable;
 80006cc:	687a      	ldr	r2, [r7, #4]
 80006ce:	8993      	ldrh	r3, [r2, #12]
 80006d0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80006d4:	8193      	strh	r3, [r2, #12]
			break;
 80006d6:	e005      	b.n	80006e4 <MCAL_USART_Init+0x22c>
		case Interrupt_TC_Enable:
			USARTx->USART_CR1.BIT_Name.TCIE=USART_Interrupt_Enable;
 80006d8:	687a      	ldr	r2, [r7, #4]
 80006da:	8993      	ldrh	r3, [r2, #12]
 80006dc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80006e0:	8193      	strh	r3, [r2, #12]
			break;
 80006e2:	bf00      	nop

		}
		if(USARTx == USART1){
 80006e4:	687b      	ldr	r3, [r7, #4]
 80006e6:	4a11      	ldr	r2, [pc, #68]	; (800072c <MCAL_USART_Init+0x274>)
 80006e8:	4293      	cmp	r3, r2
 80006ea:	d106      	bne.n	80006fa <MCAL_USART_Init+0x242>
			USART1_NVIC_EN();
 80006ec:	4b14      	ldr	r3, [pc, #80]	; (8000740 <MCAL_USART_Init+0x288>)
 80006ee:	681b      	ldr	r3, [r3, #0]
 80006f0:	4a13      	ldr	r2, [pc, #76]	; (8000740 <MCAL_USART_Init+0x288>)
 80006f2:	f043 0320 	orr.w	r3, r3, #32
 80006f6:	6013      	str	r3, [r2, #0]
 80006f8:	e044      	b.n	8000784 <MCAL_USART_Init+0x2cc>
		}else if(USARTx == USART2){
 80006fa:	687b      	ldr	r3, [r7, #4]
 80006fc:	4a0d      	ldr	r2, [pc, #52]	; (8000734 <MCAL_USART_Init+0x27c>)
 80006fe:	4293      	cmp	r3, r2
 8000700:	d106      	bne.n	8000710 <MCAL_USART_Init+0x258>
			USART2_NVIC_EN();
 8000702:	4b0f      	ldr	r3, [pc, #60]	; (8000740 <MCAL_USART_Init+0x288>)
 8000704:	681b      	ldr	r3, [r3, #0]
 8000706:	4a0e      	ldr	r2, [pc, #56]	; (8000740 <MCAL_USART_Init+0x288>)
 8000708:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800070c:	6013      	str	r3, [r2, #0]
 800070e:	e039      	b.n	8000784 <MCAL_USART_Init+0x2cc>
		}else if(USARTx == USART3){
 8000710:	687b      	ldr	r3, [r7, #4]
 8000712:	4a09      	ldr	r2, [pc, #36]	; (8000738 <MCAL_USART_Init+0x280>)
 8000714:	4293      	cmp	r3, r2
 8000716:	d135      	bne.n	8000784 <MCAL_USART_Init+0x2cc>
			USART3_NVIC_EN();
 8000718:	4b09      	ldr	r3, [pc, #36]	; (8000740 <MCAL_USART_Init+0x288>)
 800071a:	681b      	ldr	r3, [r3, #0]
 800071c:	4a08      	ldr	r2, [pc, #32]	; (8000740 <MCAL_USART_Init+0x288>)
 800071e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000722:	6013      	str	r3, [r2, #0]
 8000724:	e02e      	b.n	8000784 <MCAL_USART_Init+0x2cc>
 8000726:	bf00      	nop
 8000728:	20000038 	.word	0x20000038
 800072c:	40013800 	.word	0x40013800
 8000730:	40021000 	.word	0x40021000
 8000734:	40004400 	.word	0x40004400
 8000738:	40004800 	.word	0x40004800
 800073c:	51eb851f 	.word	0x51eb851f
 8000740:	e000e104 	.word	0xe000e104
		}
	}else{

		if(USARTx == USART1){
 8000744:	687b      	ldr	r3, [r7, #4]
 8000746:	4a13      	ldr	r2, [pc, #76]	; (8000794 <MCAL_USART_Init+0x2dc>)
 8000748:	4293      	cmp	r3, r2
 800074a:	d106      	bne.n	800075a <MCAL_USART_Init+0x2a2>
			USART1_NVIC_DIS();
 800074c:	4b12      	ldr	r3, [pc, #72]	; (8000798 <MCAL_USART_Init+0x2e0>)
 800074e:	681b      	ldr	r3, [r3, #0]
 8000750:	4a11      	ldr	r2, [pc, #68]	; (8000798 <MCAL_USART_Init+0x2e0>)
 8000752:	f043 0320 	orr.w	r3, r3, #32
 8000756:	6013      	str	r3, [r2, #0]
 8000758:	e014      	b.n	8000784 <MCAL_USART_Init+0x2cc>
		}else if(USARTx == USART2){
 800075a:	687b      	ldr	r3, [r7, #4]
 800075c:	4a0f      	ldr	r2, [pc, #60]	; (800079c <MCAL_USART_Init+0x2e4>)
 800075e:	4293      	cmp	r3, r2
 8000760:	d106      	bne.n	8000770 <MCAL_USART_Init+0x2b8>
			USART2_NVIC_DIS();
 8000762:	4b0d      	ldr	r3, [pc, #52]	; (8000798 <MCAL_USART_Init+0x2e0>)
 8000764:	681b      	ldr	r3, [r3, #0]
 8000766:	4a0c      	ldr	r2, [pc, #48]	; (8000798 <MCAL_USART_Init+0x2e0>)
 8000768:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800076c:	6013      	str	r3, [r2, #0]
 800076e:	e009      	b.n	8000784 <MCAL_USART_Init+0x2cc>
		}else if(USARTx == USART3){
 8000770:	687b      	ldr	r3, [r7, #4]
 8000772:	4a0b      	ldr	r2, [pc, #44]	; (80007a0 <MCAL_USART_Init+0x2e8>)
 8000774:	4293      	cmp	r3, r2
 8000776:	d105      	bne.n	8000784 <MCAL_USART_Init+0x2cc>
			USART3_NVIC_DIS();
 8000778:	4b07      	ldr	r3, [pc, #28]	; (8000798 <MCAL_USART_Init+0x2e0>)
 800077a:	681b      	ldr	r3, [r3, #0]
 800077c:	4a06      	ldr	r2, [pc, #24]	; (8000798 <MCAL_USART_Init+0x2e0>)
 800077e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000782:	6013      	str	r3, [r2, #0]
		}
	}


	MCAL_USART_GPIO_Set_Pins(USARTx);
 8000784:	6878      	ldr	r0, [r7, #4]
 8000786:	f000 f851 	bl	800082c <MCAL_USART_GPIO_Set_Pins>
}
 800078a:	bf00      	nop
 800078c:	3724      	adds	r7, #36	; 0x24
 800078e:	46bd      	mov	sp, r7
 8000790:	bd90      	pop	{r4, r7, pc}
 8000792:	bf00      	nop
 8000794:	40013800 	.word	0x40013800
 8000798:	e000e184 	.word	0xe000e184
 800079c:	40004400 	.word	0x40004400
 80007a0:	40004800 	.word	0x40004800

080007a4 <MCAL_USART_ReceiveData>:
}
void MCAL_USART_Check_Last_Buffer(USART_Reg* USARTx){

	while(!USARTx->USART_SR.BIT_Name.TC);
}
void MCAL_USART_ReceiveData(USART_Reg* USARTx, uint16 * P_Buffer,Interrupt_Status Interrupt){
 80007a4:	b480      	push	{r7}
 80007a6:	b085      	sub	sp, #20
 80007a8:	af00      	add	r7, sp, #0
 80007aa:	60f8      	str	r0, [r7, #12]
 80007ac:	60b9      	str	r1, [r7, #8]
 80007ae:	4613      	mov	r3, r2
 80007b0:	71fb      	strb	r3, [r7, #7]
	if(Interrupt == Disable)
 80007b2:	79fb      	ldrb	r3, [r7, #7]
 80007b4:	2b00      	cmp	r3, #0
 80007b6:	d107      	bne.n	80007c8 <MCAL_USART_ReceiveData+0x24>
		while(!USARTx->USART_SR.BIT_Name.RXNE);
 80007b8:	bf00      	nop
 80007ba:	68fb      	ldr	r3, [r7, #12]
 80007bc:	681b      	ldr	r3, [r3, #0]
 80007be:	f3c3 1340 	ubfx	r3, r3, #5, #1
 80007c2:	b2db      	uxtb	r3, r3
 80007c4:	2b00      	cmp	r3, #0
 80007c6:	d0f8      	beq.n	80007ba <MCAL_USART_ReceiveData+0x16>
	if(Global_Config.Parity == none){
 80007c8:	4b17      	ldr	r3, [pc, #92]	; (8000828 <MCAL_USART_ReceiveData+0x84>)
 80007ca:	7a9b      	ldrb	r3, [r3, #10]
 80007cc:	2b02      	cmp	r3, #2
 80007ce:	d111      	bne.n	80007f4 <MCAL_USART_ReceiveData+0x50>
		if(Global_Config.Length == Nine_Bit){
 80007d0:	4b15      	ldr	r3, [pc, #84]	; (8000828 <MCAL_USART_ReceiveData+0x84>)
 80007d2:	781b      	ldrb	r3, [r3, #0]
 80007d4:	2b01      	cmp	r3, #1
 80007d6:	d106      	bne.n	80007e6 <MCAL_USART_ReceiveData+0x42>

			*((uint16 *)P_Buffer)=USARTx->USART_DR.BIT_Name.DR;
 80007d8:	68fb      	ldr	r3, [r7, #12]
 80007da:	685b      	ldr	r3, [r3, #4]
 80007dc:	b2db      	uxtb	r3, r3
 80007de:	b29a      	uxth	r2, r3
 80007e0:	68bb      	ldr	r3, [r7, #8]
 80007e2:	801a      	strh	r2, [r3, #0]
			*((uint16 *)P_Buffer) = (USARTx->USART_DR.BIT_Name.DR & (0xFF));
		}else{
			*((uint16 *)P_Buffer) = (USARTx->USART_DR.BIT_Name.DR & (0x7F));
		}
	}
}
 80007e4:	e01a      	b.n	800081c <MCAL_USART_ReceiveData+0x78>
			*((uint16 *)P_Buffer) = (USARTx->USART_DR.BIT_Name.DR & (0xFF));
 80007e6:	68fb      	ldr	r3, [r7, #12]
 80007e8:	685b      	ldr	r3, [r3, #4]
 80007ea:	b2db      	uxtb	r3, r3
 80007ec:	b29a      	uxth	r2, r3
 80007ee:	68bb      	ldr	r3, [r7, #8]
 80007f0:	801a      	strh	r2, [r3, #0]
}
 80007f2:	e013      	b.n	800081c <MCAL_USART_ReceiveData+0x78>
		if(Global_Config.Length == Nine_Bit){
 80007f4:	4b0c      	ldr	r3, [pc, #48]	; (8000828 <MCAL_USART_ReceiveData+0x84>)
 80007f6:	781b      	ldrb	r3, [r3, #0]
 80007f8:	2b01      	cmp	r3, #1
 80007fa:	d106      	bne.n	800080a <MCAL_USART_ReceiveData+0x66>
			*((uint16 *)P_Buffer) = (USARTx->USART_DR.BIT_Name.DR & (0xFF));
 80007fc:	68fb      	ldr	r3, [r7, #12]
 80007fe:	685b      	ldr	r3, [r3, #4]
 8000800:	b2db      	uxtb	r3, r3
 8000802:	b29a      	uxth	r2, r3
 8000804:	68bb      	ldr	r3, [r7, #8]
 8000806:	801a      	strh	r2, [r3, #0]
}
 8000808:	e008      	b.n	800081c <MCAL_USART_ReceiveData+0x78>
			*((uint16 *)P_Buffer) = (USARTx->USART_DR.BIT_Name.DR & (0x7F));
 800080a:	68fb      	ldr	r3, [r7, #12]
 800080c:	685b      	ldr	r3, [r3, #4]
 800080e:	b2db      	uxtb	r3, r3
 8000810:	b29b      	uxth	r3, r3
 8000812:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8000816:	b29a      	uxth	r2, r3
 8000818:	68bb      	ldr	r3, [r7, #8]
 800081a:	801a      	strh	r2, [r3, #0]
}
 800081c:	bf00      	nop
 800081e:	3714      	adds	r7, #20
 8000820:	46bd      	mov	sp, r7
 8000822:	bc80      	pop	{r7}
 8000824:	4770      	bx	lr
 8000826:	bf00      	nop
 8000828:	20000038 	.word	0x20000038

0800082c <MCAL_USART_GPIO_Set_Pins>:
void MCAL_USART_GPIO_Set_Pins(USART_Reg* USARTx){
 800082c:	b580      	push	{r7, lr}
 800082e:	b084      	sub	sp, #16
 8000830:	af00      	add	r7, sp, #0
 8000832:	6078      	str	r0, [r7, #4]
	GPIO_PIN_Config USART_Config;
	//USART1 >> PA9 TX >>>PA10 RX >>> PA11 CTS  >>>> PA12 RTS
	//USART2  >> PA2 TX >>>PA3 RX >>> PA0 CTS  >>>> PA1 RTS
	//USART3  >> PB10 TX >>>PB11 RX >>> PB13 CTS  >>>> PB14 RTS
	if(USARTx == USART1){
 8000834:	687b      	ldr	r3, [r7, #4]
 8000836:	4a7f      	ldr	r2, [pc, #508]	; (8000a34 <MCAL_USART_GPIO_Set_Pins+0x208>)
 8000838:	4293      	cmp	r3, r2
 800083a:	d14f      	bne.n	80008dc <MCAL_USART_GPIO_Set_Pins+0xb0>
		if((Global_Config.Mode == Transmitter) || (Global_Config.Mode == Both) ){
 800083c:	4b7e      	ldr	r3, [pc, #504]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 800083e:	789b      	ldrb	r3, [r3, #2]
 8000840:	2b00      	cmp	r3, #0
 8000842:	d003      	beq.n	800084c <MCAL_USART_GPIO_Set_Pins+0x20>
 8000844:	4b7c      	ldr	r3, [pc, #496]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 8000846:	789b      	ldrb	r3, [r3, #2]
 8000848:	2b02      	cmp	r3, #2
 800084a:	d10b      	bne.n	8000864 <MCAL_USART_GPIO_Set_Pins+0x38>
			//Configure TX ALT_OUTPUT_PP
			USART_Config.Mode=ALT_OUTPUT_PP;
 800084c:	2306      	movs	r3, #6
 800084e:	73bb      	strb	r3, [r7, #14]
			USART_Config.speed=Max_speed_10MHZ;
 8000850:	2301      	movs	r3, #1
 8000852:	737b      	strb	r3, [r7, #13]
			USART_Config.Pin_Num = USART1_TX_MCAL_PIN;
 8000854:	2309      	movs	r3, #9
 8000856:	733b      	strb	r3, [r7, #12]
			MCAL_GPIO_Init(USART1_TX_MCAL_PORT,&USART_Config);
 8000858:	f107 030c 	add.w	r3, r7, #12
 800085c:	4619      	mov	r1, r3
 800085e:	4877      	ldr	r0, [pc, #476]	; (8000a3c <MCAL_USART_GPIO_Set_Pins+0x210>)
 8000860:	f000 f9b6 	bl	8000bd0 <MCAL_GPIO_Init>
		}
		if((Global_Config.Mode == Recevier) || (Global_Config.Mode == Both) ){
 8000864:	4b74      	ldr	r3, [pc, #464]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 8000866:	789b      	ldrb	r3, [r3, #2]
 8000868:	2b01      	cmp	r3, #1
 800086a:	d003      	beq.n	8000874 <MCAL_USART_GPIO_Set_Pins+0x48>
 800086c:	4b72      	ldr	r3, [pc, #456]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 800086e:	789b      	ldrb	r3, [r3, #2]
 8000870:	2b02      	cmp	r3, #2
 8000872:	d10b      	bne.n	800088c <MCAL_USART_GPIO_Set_Pins+0x60>
			//Configure RX Input floating / Input pull-up
			USART_Config.Mode=Floating_Mode;
 8000874:	2301      	movs	r3, #1
 8000876:	73bb      	strb	r3, [r7, #14]
			USART_Config.speed=Max_speed_10MHZ;
 8000878:	2301      	movs	r3, #1
 800087a:	737b      	strb	r3, [r7, #13]
			USART_Config.Pin_Num = USART1_RX_MCAL_PIN;
 800087c:	230a      	movs	r3, #10
 800087e:	733b      	strb	r3, [r7, #12]
			MCAL_GPIO_Init(USART1_RX_MCAL_PORT,&USART_Config);
 8000880:	f107 030c 	add.w	r3, r7, #12
 8000884:	4619      	mov	r1, r3
 8000886:	486d      	ldr	r0, [pc, #436]	; (8000a3c <MCAL_USART_GPIO_Set_Pins+0x210>)
 8000888:	f000 f9a2 	bl	8000bd0 <MCAL_GPIO_Init>
		}
		if((Global_Config.HW_Flow == RTS) || (Global_Config.HW_Flow == CTS_RTS) ){
 800088c:	4b6a      	ldr	r3, [pc, #424]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 800088e:	7adb      	ldrb	r3, [r3, #11]
 8000890:	2b01      	cmp	r3, #1
 8000892:	d003      	beq.n	800089c <MCAL_USART_GPIO_Set_Pins+0x70>
 8000894:	4b68      	ldr	r3, [pc, #416]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 8000896:	7adb      	ldrb	r3, [r3, #11]
 8000898:	2b03      	cmp	r3, #3
 800089a:	d10b      	bne.n	80008b4 <MCAL_USART_GPIO_Set_Pins+0x88>
			//Configure RTS ALT_OUTPUT_PP
			USART_Config.Mode=ALT_OUTPUT_PP;
 800089c:	2306      	movs	r3, #6
 800089e:	73bb      	strb	r3, [r7, #14]
			USART_Config.speed=Max_speed_10MHZ;
 80008a0:	2301      	movs	r3, #1
 80008a2:	737b      	strb	r3, [r7, #13]
			USART_Config.Pin_Num = USART1_RTS_MCAL_PIN;
 80008a4:	230c      	movs	r3, #12
 80008a6:	733b      	strb	r3, [r7, #12]
			MCAL_GPIO_Init(USART1_RTS_MCAL_PORT,&USART_Config);
 80008a8:	f107 030c 	add.w	r3, r7, #12
 80008ac:	4619      	mov	r1, r3
 80008ae:	4863      	ldr	r0, [pc, #396]	; (8000a3c <MCAL_USART_GPIO_Set_Pins+0x210>)
 80008b0:	f000 f98e 	bl	8000bd0 <MCAL_GPIO_Init>
		}
		if((Global_Config.HW_Flow == CTS) || (Global_Config.HW_Flow == CTS_RTS) ){
 80008b4:	4b60      	ldr	r3, [pc, #384]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 80008b6:	7adb      	ldrb	r3, [r3, #11]
 80008b8:	2b02      	cmp	r3, #2
 80008ba:	d003      	beq.n	80008c4 <MCAL_USART_GPIO_Set_Pins+0x98>
 80008bc:	4b5e      	ldr	r3, [pc, #376]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 80008be:	7adb      	ldrb	r3, [r3, #11]
 80008c0:	2b03      	cmp	r3, #3
 80008c2:	d10b      	bne.n	80008dc <MCAL_USART_GPIO_Set_Pins+0xb0>
			//Configure CTS Input floating / Input pull-up
			USART_Config.Mode=Floating_Mode;
 80008c4:	2301      	movs	r3, #1
 80008c6:	73bb      	strb	r3, [r7, #14]
			USART_Config.speed=Max_speed_10MHZ;
 80008c8:	2301      	movs	r3, #1
 80008ca:	737b      	strb	r3, [r7, #13]
			USART_Config.Pin_Num = USART1_CTS_MCAL_PIN;
 80008cc:	230b      	movs	r3, #11
 80008ce:	733b      	strb	r3, [r7, #12]
			MCAL_GPIO_Init(USART1_CTS_MCAL_PORT,&USART_Config);
 80008d0:	f107 030c 	add.w	r3, r7, #12
 80008d4:	4619      	mov	r1, r3
 80008d6:	4859      	ldr	r0, [pc, #356]	; (8000a3c <MCAL_USART_GPIO_Set_Pins+0x210>)
 80008d8:	f000 f97a 	bl	8000bd0 <MCAL_GPIO_Init>
		}

	}
	if(USARTx == USART2){
 80008dc:	687b      	ldr	r3, [r7, #4]
 80008de:	4a58      	ldr	r2, [pc, #352]	; (8000a40 <MCAL_USART_GPIO_Set_Pins+0x214>)
 80008e0:	4293      	cmp	r3, r2
 80008e2:	d14f      	bne.n	8000984 <MCAL_USART_GPIO_Set_Pins+0x158>
		if((Global_Config.Mode == Transmitter) || (Global_Config.Mode == Both) ){
 80008e4:	4b54      	ldr	r3, [pc, #336]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 80008e6:	789b      	ldrb	r3, [r3, #2]
 80008e8:	2b00      	cmp	r3, #0
 80008ea:	d003      	beq.n	80008f4 <MCAL_USART_GPIO_Set_Pins+0xc8>
 80008ec:	4b52      	ldr	r3, [pc, #328]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 80008ee:	789b      	ldrb	r3, [r3, #2]
 80008f0:	2b02      	cmp	r3, #2
 80008f2:	d10b      	bne.n	800090c <MCAL_USART_GPIO_Set_Pins+0xe0>
			//Configure TX ALT_OUTPUT_PP
			USART_Config.Mode=ALT_OUTPUT_PP;
 80008f4:	2306      	movs	r3, #6
 80008f6:	73bb      	strb	r3, [r7, #14]
			USART_Config.speed=Max_speed_10MHZ;
 80008f8:	2301      	movs	r3, #1
 80008fa:	737b      	strb	r3, [r7, #13]
			USART_Config.Pin_Num = USART2_TX_MCAL_PIN;
 80008fc:	2302      	movs	r3, #2
 80008fe:	733b      	strb	r3, [r7, #12]
			MCAL_GPIO_Init(USART2_TX_MCAL_PORT,&USART_Config);
 8000900:	f107 030c 	add.w	r3, r7, #12
 8000904:	4619      	mov	r1, r3
 8000906:	484d      	ldr	r0, [pc, #308]	; (8000a3c <MCAL_USART_GPIO_Set_Pins+0x210>)
 8000908:	f000 f962 	bl	8000bd0 <MCAL_GPIO_Init>
		}
		if((Global_Config.Mode == Recevier) || (Global_Config.Mode == Both) ){
 800090c:	4b4a      	ldr	r3, [pc, #296]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 800090e:	789b      	ldrb	r3, [r3, #2]
 8000910:	2b01      	cmp	r3, #1
 8000912:	d003      	beq.n	800091c <MCAL_USART_GPIO_Set_Pins+0xf0>
 8000914:	4b48      	ldr	r3, [pc, #288]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 8000916:	789b      	ldrb	r3, [r3, #2]
 8000918:	2b02      	cmp	r3, #2
 800091a:	d10b      	bne.n	8000934 <MCAL_USART_GPIO_Set_Pins+0x108>
			//Configure RX Input floating / Input pull-up
			USART_Config.Mode=Floating_Mode;
 800091c:	2301      	movs	r3, #1
 800091e:	73bb      	strb	r3, [r7, #14]
			USART_Config.speed=Max_speed_10MHZ;
 8000920:	2301      	movs	r3, #1
 8000922:	737b      	strb	r3, [r7, #13]
			USART_Config.Pin_Num = USART2_RX_MCAL_PIN;
 8000924:	2303      	movs	r3, #3
 8000926:	733b      	strb	r3, [r7, #12]
			MCAL_GPIO_Init(USART2_RX_MCAL_PORT,&USART_Config);
 8000928:	f107 030c 	add.w	r3, r7, #12
 800092c:	4619      	mov	r1, r3
 800092e:	4843      	ldr	r0, [pc, #268]	; (8000a3c <MCAL_USART_GPIO_Set_Pins+0x210>)
 8000930:	f000 f94e 	bl	8000bd0 <MCAL_GPIO_Init>
		}
		if((Global_Config.HW_Flow == RTS) || (Global_Config.HW_Flow == CTS_RTS) ){
 8000934:	4b40      	ldr	r3, [pc, #256]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 8000936:	7adb      	ldrb	r3, [r3, #11]
 8000938:	2b01      	cmp	r3, #1
 800093a:	d003      	beq.n	8000944 <MCAL_USART_GPIO_Set_Pins+0x118>
 800093c:	4b3e      	ldr	r3, [pc, #248]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 800093e:	7adb      	ldrb	r3, [r3, #11]
 8000940:	2b03      	cmp	r3, #3
 8000942:	d10b      	bne.n	800095c <MCAL_USART_GPIO_Set_Pins+0x130>
			//Configure RTS ALT_OUTPUT_PP
			USART_Config.Mode=ALT_OUTPUT_PP;
 8000944:	2306      	movs	r3, #6
 8000946:	73bb      	strb	r3, [r7, #14]
			USART_Config.speed=Max_speed_10MHZ;
 8000948:	2301      	movs	r3, #1
 800094a:	737b      	strb	r3, [r7, #13]
			USART_Config.Pin_Num = USART2_RTS_MCAL_PIN;
 800094c:	2301      	movs	r3, #1
 800094e:	733b      	strb	r3, [r7, #12]
			MCAL_GPIO_Init(USART2_RTS_MCAL_PORT,&USART_Config);
 8000950:	f107 030c 	add.w	r3, r7, #12
 8000954:	4619      	mov	r1, r3
 8000956:	4839      	ldr	r0, [pc, #228]	; (8000a3c <MCAL_USART_GPIO_Set_Pins+0x210>)
 8000958:	f000 f93a 	bl	8000bd0 <MCAL_GPIO_Init>
		}
		if((Global_Config.HW_Flow == CTS) || (Global_Config.HW_Flow == CTS_RTS) ){
 800095c:	4b36      	ldr	r3, [pc, #216]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 800095e:	7adb      	ldrb	r3, [r3, #11]
 8000960:	2b02      	cmp	r3, #2
 8000962:	d003      	beq.n	800096c <MCAL_USART_GPIO_Set_Pins+0x140>
 8000964:	4b34      	ldr	r3, [pc, #208]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 8000966:	7adb      	ldrb	r3, [r3, #11]
 8000968:	2b03      	cmp	r3, #3
 800096a:	d10b      	bne.n	8000984 <MCAL_USART_GPIO_Set_Pins+0x158>
			//Configure CTS Input floating / Input pull-up
			USART_Config.Mode=Floating_Mode;
 800096c:	2301      	movs	r3, #1
 800096e:	73bb      	strb	r3, [r7, #14]
			USART_Config.speed=Max_speed_10MHZ;
 8000970:	2301      	movs	r3, #1
 8000972:	737b      	strb	r3, [r7, #13]
			USART_Config.Pin_Num = USART2_CTS_MCAL_PIN;
 8000974:	2300      	movs	r3, #0
 8000976:	733b      	strb	r3, [r7, #12]
			MCAL_GPIO_Init(USART2_CTS_MCAL_PORT,&USART_Config);
 8000978:	f107 030c 	add.w	r3, r7, #12
 800097c:	4619      	mov	r1, r3
 800097e:	482f      	ldr	r0, [pc, #188]	; (8000a3c <MCAL_USART_GPIO_Set_Pins+0x210>)
 8000980:	f000 f926 	bl	8000bd0 <MCAL_GPIO_Init>
		}

	}
	if(USARTx == USART3){
 8000984:	687b      	ldr	r3, [r7, #4]
 8000986:	4a2f      	ldr	r2, [pc, #188]	; (8000a44 <MCAL_USART_GPIO_Set_Pins+0x218>)
 8000988:	4293      	cmp	r3, r2
 800098a:	d14f      	bne.n	8000a2c <MCAL_USART_GPIO_Set_Pins+0x200>
		if((Global_Config.Mode == Transmitter) || (Global_Config.Mode == Both) ){
 800098c:	4b2a      	ldr	r3, [pc, #168]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 800098e:	789b      	ldrb	r3, [r3, #2]
 8000990:	2b00      	cmp	r3, #0
 8000992:	d003      	beq.n	800099c <MCAL_USART_GPIO_Set_Pins+0x170>
 8000994:	4b28      	ldr	r3, [pc, #160]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 8000996:	789b      	ldrb	r3, [r3, #2]
 8000998:	2b02      	cmp	r3, #2
 800099a:	d10b      	bne.n	80009b4 <MCAL_USART_GPIO_Set_Pins+0x188>
			//Configure TX ALT_OUTPUT_PP
			USART_Config.Mode=ALT_OUTPUT_PP;
 800099c:	2306      	movs	r3, #6
 800099e:	73bb      	strb	r3, [r7, #14]
			USART_Config.speed=Max_speed_10MHZ;
 80009a0:	2301      	movs	r3, #1
 80009a2:	737b      	strb	r3, [r7, #13]
			USART_Config.Pin_Num = USART3_TX_MCAL_PIN;
 80009a4:	230a      	movs	r3, #10
 80009a6:	733b      	strb	r3, [r7, #12]
			MCAL_GPIO_Init(USART3_TX_MCAL_PORT,&USART_Config);
 80009a8:	f107 030c 	add.w	r3, r7, #12
 80009ac:	4619      	mov	r1, r3
 80009ae:	4826      	ldr	r0, [pc, #152]	; (8000a48 <MCAL_USART_GPIO_Set_Pins+0x21c>)
 80009b0:	f000 f90e 	bl	8000bd0 <MCAL_GPIO_Init>
		}
		if((Global_Config.Mode == Recevier) || (Global_Config.Mode == Both) ){
 80009b4:	4b20      	ldr	r3, [pc, #128]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 80009b6:	789b      	ldrb	r3, [r3, #2]
 80009b8:	2b01      	cmp	r3, #1
 80009ba:	d003      	beq.n	80009c4 <MCAL_USART_GPIO_Set_Pins+0x198>
 80009bc:	4b1e      	ldr	r3, [pc, #120]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 80009be:	789b      	ldrb	r3, [r3, #2]
 80009c0:	2b02      	cmp	r3, #2
 80009c2:	d10b      	bne.n	80009dc <MCAL_USART_GPIO_Set_Pins+0x1b0>
			//Configure RX Input floating / Input pull-up
			USART_Config.Mode=Floating_Mode;
 80009c4:	2301      	movs	r3, #1
 80009c6:	73bb      	strb	r3, [r7, #14]
			USART_Config.speed=Max_speed_10MHZ;
 80009c8:	2301      	movs	r3, #1
 80009ca:	737b      	strb	r3, [r7, #13]
			USART_Config.Pin_Num = USART3_RX_MCAL_PIN;
 80009cc:	230b      	movs	r3, #11
 80009ce:	733b      	strb	r3, [r7, #12]
			MCAL_GPIO_Init(USART3_RX_MCAL_PORT,&USART_Config);
 80009d0:	f107 030c 	add.w	r3, r7, #12
 80009d4:	4619      	mov	r1, r3
 80009d6:	481c      	ldr	r0, [pc, #112]	; (8000a48 <MCAL_USART_GPIO_Set_Pins+0x21c>)
 80009d8:	f000 f8fa 	bl	8000bd0 <MCAL_GPIO_Init>
		}
		if((Global_Config.HW_Flow == RTS) || (Global_Config.HW_Flow == CTS_RTS) ){
 80009dc:	4b16      	ldr	r3, [pc, #88]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 80009de:	7adb      	ldrb	r3, [r3, #11]
 80009e0:	2b01      	cmp	r3, #1
 80009e2:	d003      	beq.n	80009ec <MCAL_USART_GPIO_Set_Pins+0x1c0>
 80009e4:	4b14      	ldr	r3, [pc, #80]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 80009e6:	7adb      	ldrb	r3, [r3, #11]
 80009e8:	2b03      	cmp	r3, #3
 80009ea:	d10b      	bne.n	8000a04 <MCAL_USART_GPIO_Set_Pins+0x1d8>
			//Configure RTS ALT_OUTPUT_PP
			USART_Config.Mode=ALT_OUTPUT_PP;
 80009ec:	2306      	movs	r3, #6
 80009ee:	73bb      	strb	r3, [r7, #14]
			USART_Config.speed=Max_speed_10MHZ;
 80009f0:	2301      	movs	r3, #1
 80009f2:	737b      	strb	r3, [r7, #13]
			USART_Config.Pin_Num = USART3_RTS_MCAL_PIN;
 80009f4:	230e      	movs	r3, #14
 80009f6:	733b      	strb	r3, [r7, #12]
			MCAL_GPIO_Init(USART3_RTS_MCAL_PORT,&USART_Config);
 80009f8:	f107 030c 	add.w	r3, r7, #12
 80009fc:	4619      	mov	r1, r3
 80009fe:	4812      	ldr	r0, [pc, #72]	; (8000a48 <MCAL_USART_GPIO_Set_Pins+0x21c>)
 8000a00:	f000 f8e6 	bl	8000bd0 <MCAL_GPIO_Init>
		}
		if((Global_Config.HW_Flow == CTS) || (Global_Config.HW_Flow == CTS_RTS) ){
 8000a04:	4b0c      	ldr	r3, [pc, #48]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 8000a06:	7adb      	ldrb	r3, [r3, #11]
 8000a08:	2b02      	cmp	r3, #2
 8000a0a:	d003      	beq.n	8000a14 <MCAL_USART_GPIO_Set_Pins+0x1e8>
 8000a0c:	4b0a      	ldr	r3, [pc, #40]	; (8000a38 <MCAL_USART_GPIO_Set_Pins+0x20c>)
 8000a0e:	7adb      	ldrb	r3, [r3, #11]
 8000a10:	2b03      	cmp	r3, #3
 8000a12:	d10b      	bne.n	8000a2c <MCAL_USART_GPIO_Set_Pins+0x200>
			//Configure CTS Input floating / Input pull-up
			USART_Config.Mode=Floating_Mode;
 8000a14:	2301      	movs	r3, #1
 8000a16:	73bb      	strb	r3, [r7, #14]
			USART_Config.speed=Max_speed_10MHZ;
 8000a18:	2301      	movs	r3, #1
 8000a1a:	737b      	strb	r3, [r7, #13]
			USART_Config.Pin_Num = USART3_CTS_MCAL_PIN;
 8000a1c:	230d      	movs	r3, #13
 8000a1e:	733b      	strb	r3, [r7, #12]
			MCAL_GPIO_Init(USART3_CTS_MCAL_PORT,&USART_Config);
 8000a20:	f107 030c 	add.w	r3, r7, #12
 8000a24:	4619      	mov	r1, r3
 8000a26:	4808      	ldr	r0, [pc, #32]	; (8000a48 <MCAL_USART_GPIO_Set_Pins+0x21c>)
 8000a28:	f000 f8d2 	bl	8000bd0 <MCAL_GPIO_Init>
		}

	}

}
 8000a2c:	bf00      	nop
 8000a2e:	3710      	adds	r7, #16
 8000a30:	46bd      	mov	sp, r7
 8000a32:	bd80      	pop	{r7, pc}
 8000a34:	40013800 	.word	0x40013800
 8000a38:	20000038 	.word	0x20000038
 8000a3c:	40010800 	.word	0x40010800
 8000a40:	40004400 	.word	0x40004400
 8000a44:	40004800 	.word	0x40004800
 8000a48:	40010c00 	.word	0x40010c00

08000a4c <Get_SYS_CLK>:
uint32	Get_SYS_CLK(void){
 8000a4c:	b480      	push	{r7}
 8000a4e:	af00      	add	r7, sp, #0
	Set and cleared by hardware to indicate which clock source is used as system clock.
	00: HSI oscillator used as system clock
	01: HSE oscillator used as system clock
	10: PLL used as system clock
	11: not applicable*/
	switch((RCC->RCC_CFGR>>2) &(0b11)){
 8000a50:	4b0b      	ldr	r3, [pc, #44]	; (8000a80 <Get_SYS_CLK+0x34>)
 8000a52:	685b      	ldr	r3, [r3, #4]
 8000a54:	089b      	lsrs	r3, r3, #2
 8000a56:	f003 0303 	and.w	r3, r3, #3
 8000a5a:	2b01      	cmp	r3, #1
 8000a5c:	d006      	beq.n	8000a6c <Get_SYS_CLK+0x20>
 8000a5e:	2b01      	cmp	r3, #1
 8000a60:	d302      	bcc.n	8000a68 <Get_SYS_CLK+0x1c>
 8000a62:	2b02      	cmp	r3, #2
 8000a64:	d004      	beq.n	8000a70 <Get_SYS_CLK+0x24>
 8000a66:	e005      	b.n	8000a74 <Get_SYS_CLK+0x28>
	case 0:
		return HSI;
 8000a68:	4b06      	ldr	r3, [pc, #24]	; (8000a84 <Get_SYS_CLK+0x38>)
 8000a6a:	e004      	b.n	8000a76 <Get_SYS_CLK+0x2a>
		break;
	case 1:
		return HSE;
 8000a6c:	4b05      	ldr	r3, [pc, #20]	; (8000a84 <Get_SYS_CLK+0x38>)
 8000a6e:	e002      	b.n	8000a76 <Get_SYS_CLK+0x2a>
		break;
	case 2:
		return PLL;
 8000a70:	4b04      	ldr	r3, [pc, #16]	; (8000a84 <Get_SYS_CLK+0x38>)
 8000a72:	e000      	b.n	8000a76 <Get_SYS_CLK+0x2a>
		break;
	default :
		return ERROR;
 8000a74:	2300      	movs	r3, #0
		break;
	}
}
 8000a76:	4618      	mov	r0, r3
 8000a78:	46bd      	mov	sp, r7
 8000a7a:	bc80      	pop	{r7}
 8000a7c:	4770      	bx	lr
 8000a7e:	bf00      	nop
 8000a80:	40021000 	.word	0x40021000
 8000a84:	007a1200 	.word	0x007a1200

08000a88 <Get_AHB_CLK>:
uint32	Get_AHB_CLK(void){
 8000a88:	b580      	push	{r7, lr}
 8000a8a:	af00      	add	r7, sp, #0
	//Bits 7:4 HPRE: AHB prescaler

	return (Get_SYS_CLK() >> AHB_PRE_SCALER[((RCC->RCC_CFGR >> 4)& 0X0F)]);
 8000a8c:	f7ff ffde 	bl	8000a4c <Get_SYS_CLK>
 8000a90:	4601      	mov	r1, r0
 8000a92:	4b05      	ldr	r3, [pc, #20]	; (8000aa8 <Get_AHB_CLK+0x20>)
 8000a94:	685b      	ldr	r3, [r3, #4]
 8000a96:	091b      	lsrs	r3, r3, #4
 8000a98:	f003 030f 	and.w	r3, r3, #15
 8000a9c:	4a03      	ldr	r2, [pc, #12]	; (8000aac <Get_AHB_CLK+0x24>)
 8000a9e:	5cd3      	ldrb	r3, [r2, r3]
 8000aa0:	fa21 f303 	lsr.w	r3, r1, r3
}
 8000aa4:	4618      	mov	r0, r3
 8000aa6:	bd80      	pop	{r7, pc}
 8000aa8:	40021000 	.word	0x40021000
 8000aac:	20000000 	.word	0x20000000

08000ab0 <Get_APB1_CLK>:
/*uint8 AHB_PRE_SCALER[16U]={0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8};
  uint8 APB_PRE_SCALER[8U]={0,0,0,0,1,2,3,4};
 *
 * */
uint32	Get_APB1_CLK(void){
 8000ab0:	b580      	push	{r7, lr}
 8000ab2:	af00      	add	r7, sp, #0
	100: HCLK divided by 2
	101: HCLK divided by 4
	110: HCLK divided by 8
	111: HCLK divided by 16*/

	return (Get_AHB_CLK() >> APB_PRE_SCALER[((RCC->RCC_CFGR>>8) & 0b111)]  );
 8000ab4:	f7ff ffe8 	bl	8000a88 <Get_AHB_CLK>
 8000ab8:	4601      	mov	r1, r0
 8000aba:	4b05      	ldr	r3, [pc, #20]	; (8000ad0 <Get_APB1_CLK+0x20>)
 8000abc:	685b      	ldr	r3, [r3, #4]
 8000abe:	0a1b      	lsrs	r3, r3, #8
 8000ac0:	f003 0307 	and.w	r3, r3, #7
 8000ac4:	4a03      	ldr	r2, [pc, #12]	; (8000ad4 <Get_APB1_CLK+0x24>)
 8000ac6:	5cd3      	ldrb	r3, [r2, r3]
 8000ac8:	fa21 f303 	lsr.w	r3, r1, r3
}
 8000acc:	4618      	mov	r0, r3
 8000ace:	bd80      	pop	{r7, pc}
 8000ad0:	40021000 	.word	0x40021000
 8000ad4:	20000010 	.word	0x20000010

08000ad8 <Get_APB2_CLK>:
uint32	Get_APB2_CLK(void){
 8000ad8:	b580      	push	{r7, lr}
 8000ada:	af00      	add	r7, sp, #0

	return (Get_AHB_CLK() >> APB_PRE_SCALER[((RCC->RCC_CFGR >> 11) & 0b111)]);
 8000adc:	f7ff ffd4 	bl	8000a88 <Get_AHB_CLK>
 8000ae0:	4601      	mov	r1, r0
 8000ae2:	4b05      	ldr	r3, [pc, #20]	; (8000af8 <Get_APB2_CLK+0x20>)
 8000ae4:	685b      	ldr	r3, [r3, #4]
 8000ae6:	0adb      	lsrs	r3, r3, #11
 8000ae8:	f003 0307 	and.w	r3, r3, #7
 8000aec:	4a03      	ldr	r2, [pc, #12]	; (8000afc <Get_APB2_CLK+0x24>)
 8000aee:	5cd3      	ldrb	r3, [r2, r3]
 8000af0:	fa21 f303 	lsr.w	r3, r1, r3
}
 8000af4:	4618      	mov	r0, r3
 8000af6:	bd80      	pop	{r7, pc}
 8000af8:	40021000 	.word	0x40021000
 8000afc:	20000010 	.word	0x20000010

08000b00 <USART1_IRQHandler>:
void USART1_IRQHandler(void){
 8000b00:	b580      	push	{r7, lr}
 8000b02:	af00      	add	r7, sp, #0

	Global_Config.P_CallBack();
 8000b04:	4b02      	ldr	r3, [pc, #8]	; (8000b10 <USART1_IRQHandler+0x10>)
 8000b06:	68db      	ldr	r3, [r3, #12]
 8000b08:	4798      	blx	r3
}
 8000b0a:	bf00      	nop
 8000b0c:	bd80      	pop	{r7, pc}
 8000b0e:	bf00      	nop
 8000b10:	20000038 	.word	0x20000038

08000b14 <USART2_IRQHandler>:
void USART2_IRQHandler(void){
 8000b14:	b580      	push	{r7, lr}
 8000b16:	af00      	add	r7, sp, #0

	Global_Config.P_CallBack();
 8000b18:	4b02      	ldr	r3, [pc, #8]	; (8000b24 <USART2_IRQHandler+0x10>)
 8000b1a:	68db      	ldr	r3, [r3, #12]
 8000b1c:	4798      	blx	r3
}
 8000b1e:	bf00      	nop
 8000b20:	bd80      	pop	{r7, pc}
 8000b22:	bf00      	nop
 8000b24:	20000038 	.word	0x20000038

08000b28 <USART3_IRQHandler>:
void USART3_IRQHandler(void){
 8000b28:	b580      	push	{r7, lr}
 8000b2a:	af00      	add	r7, sp, #0

	Global_Config.P_CallBack();
 8000b2c:	4b02      	ldr	r3, [pc, #8]	; (8000b38 <USART3_IRQHandler+0x10>)
 8000b2e:	68db      	ldr	r3, [r3, #12]
 8000b30:	4798      	blx	r3
}
 8000b32:	bf00      	nop
 8000b34:	bd80      	pop	{r7, pc}
 8000b36:	bf00      	nop
 8000b38:	20000038 	.word	0x20000038

08000b3c <Get_CR_shif>:
 * @param[in]	- Pin number
 * @param[out]	- uint8 value for shifted position
 * @retval-		- None
 * Note-
 */
uint8 Get_CR_shif(uint8 Pin_Num){
 8000b3c:	b480      	push	{r7}
 8000b3e:	b085      	sub	sp, #20
 8000b40:	af00      	add	r7, sp, #0
 8000b42:	4603      	mov	r3, r0
 8000b44:	71fb      	strb	r3, [r7, #7]
	uint8 Shift_value;
	switch(Pin_Num){
 8000b46:	79fb      	ldrb	r3, [r7, #7]
 8000b48:	2b0f      	cmp	r3, #15
 8000b4a:	d83b      	bhi.n	8000bc4 <Get_CR_shif+0x88>
 8000b4c:	a201      	add	r2, pc, #4	; (adr r2, 8000b54 <Get_CR_shif+0x18>)
 8000b4e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000b52:	bf00      	nop
 8000b54:	08000b95 	.word	0x08000b95
 8000b58:	08000b9b 	.word	0x08000b9b
 8000b5c:	08000ba1 	.word	0x08000ba1
 8000b60:	08000ba7 	.word	0x08000ba7
 8000b64:	08000bad 	.word	0x08000bad
 8000b68:	08000bb3 	.word	0x08000bb3
 8000b6c:	08000bb9 	.word	0x08000bb9
 8000b70:	08000bbf 	.word	0x08000bbf
 8000b74:	08000b95 	.word	0x08000b95
 8000b78:	08000b9b 	.word	0x08000b9b
 8000b7c:	08000ba1 	.word	0x08000ba1
 8000b80:	08000ba7 	.word	0x08000ba7
 8000b84:	08000bad 	.word	0x08000bad
 8000b88:	08000bb3 	.word	0x08000bb3
 8000b8c:	08000bb9 	.word	0x08000bb9
 8000b90:	08000bbf 	.word	0x08000bbf
	case 8:
	case 0:
		Shift_value=0;
 8000b94:	2300      	movs	r3, #0
 8000b96:	73fb      	strb	r3, [r7, #15]
		break;
 8000b98:	e014      	b.n	8000bc4 <Get_CR_shif+0x88>
	case 9:
	case 1:
		Shift_value=4;
 8000b9a:	2304      	movs	r3, #4
 8000b9c:	73fb      	strb	r3, [r7, #15]
		break;
 8000b9e:	e011      	b.n	8000bc4 <Get_CR_shif+0x88>
	case 10:
	case 2:
		Shift_value=8;
 8000ba0:	2308      	movs	r3, #8
 8000ba2:	73fb      	strb	r3, [r7, #15]
		break;
 8000ba4:	e00e      	b.n	8000bc4 <Get_CR_shif+0x88>

	case 11:
	case 3:
		Shift_value=12;
 8000ba6:	230c      	movs	r3, #12
 8000ba8:	73fb      	strb	r3, [r7, #15]
		break;
 8000baa:	e00b      	b.n	8000bc4 <Get_CR_shif+0x88>
	case 12:
	case 4:
		Shift_value=16;
 8000bac:	2310      	movs	r3, #16
 8000bae:	73fb      	strb	r3, [r7, #15]
		break;
 8000bb0:	e008      	b.n	8000bc4 <Get_CR_shif+0x88>
	case 13:
	case 5:
		Shift_value=20;
 8000bb2:	2314      	movs	r3, #20
 8000bb4:	73fb      	strb	r3, [r7, #15]
		break;
 8000bb6:	e005      	b.n	8000bc4 <Get_CR_shif+0x88>
	case 14:
	case 6:
		Shift_value=24;
 8000bb8:	2318      	movs	r3, #24
 8000bba:	73fb      	strb	r3, [r7, #15]
		break;
 8000bbc:	e002      	b.n	8000bc4 <Get_CR_shif+0x88>
	case 15:
	case 7:
		Shift_value=28;
 8000bbe:	231c      	movs	r3, #28
 8000bc0:	73fb      	strb	r3, [r7, #15]
		break;
 8000bc2:	bf00      	nop
	}
	return Shift_value;
 8000bc4:	7bfb      	ldrb	r3, [r7, #15]

}
 8000bc6:	4618      	mov	r0, r3
 8000bc8:	3714      	adds	r7, #20
 8000bca:	46bd      	mov	sp, r7
 8000bcc:	bc80      	pop	{r7}
 8000bce:	4770      	bx	lr

08000bd0 <MCAL_GPIO_Init>:
 * @brief 		-Init port and config pin
 * @param[in]	- GPIO_Typedef pointer to port ,number of pin
 * @retval-		- None
 * Note-
 */
void MCAL_GPIO_Init(GPIO_Typedef* GPIOx,GPIO_PIN_Config* Pin_Config){
 8000bd0:	b590      	push	{r4, r7, lr}
 8000bd2:	b085      	sub	sp, #20
 8000bd4:	af00      	add	r7, sp, #0
 8000bd6:	6078      	str	r0, [r7, #4]
 8000bd8:	6039      	str	r1, [r7, #0]
	//Config register to hold adress of CR
	vuint32 *Config_Reg=NULL;
 8000bda:	2300      	movs	r3, #0
 8000bdc:	60fb      	str	r3, [r7, #12]
	if(((Pin_Config->Pin_Num)<PIN_8) && ((Pin_Config->Pin_Num)>=PIN_0)){
 8000bde:	683b      	ldr	r3, [r7, #0]
 8000be0:	781b      	ldrb	r3, [r3, #0]
 8000be2:	2b07      	cmp	r3, #7
 8000be4:	d802      	bhi.n	8000bec <MCAL_GPIO_Init+0x1c>
		Config_Reg = &(GPIOx->CRL);
 8000be6:	687b      	ldr	r3, [r7, #4]
 8000be8:	60fb      	str	r3, [r7, #12]
 8000bea:	e002      	b.n	8000bf2 <MCAL_GPIO_Init+0x22>
	}else{
		Config_Reg = &(GPIOx->CRH);
 8000bec:	687b      	ldr	r3, [r7, #4]
 8000bee:	3304      	adds	r3, #4
 8000bf0:	60fb      	str	r3, [r7, #12]
	}
	/*make the Mode and CNF zeros*/
	*Config_Reg &= ~ (0XF <<Get_CR_shif(Pin_Config->Pin_Num));
 8000bf2:	683b      	ldr	r3, [r7, #0]
 8000bf4:	781b      	ldrb	r3, [r3, #0]
 8000bf6:	4618      	mov	r0, r3
 8000bf8:	f7ff ffa0 	bl	8000b3c <Get_CR_shif>
 8000bfc:	4603      	mov	r3, r0
 8000bfe:	461a      	mov	r2, r3
 8000c00:	230f      	movs	r3, #15
 8000c02:	4093      	lsls	r3, r2
 8000c04:	43da      	mvns	r2, r3
 8000c06:	68fb      	ldr	r3, [r7, #12]
 8000c08:	681b      	ldr	r3, [r3, #0]
 8000c0a:	401a      	ands	r2, r3
 8000c0c:	68fb      	ldr	r3, [r7, #12]
 8000c0e:	601a      	str	r2, [r3, #0]
	switch(Pin_Config->Mode){
 8000c10:	683b      	ldr	r3, [r7, #0]
 8000c12:	789b      	ldrb	r3, [r3, #2]
 8000c14:	2b07      	cmp	r3, #7
 8000c16:	f200 80ce 	bhi.w	8000db6 <MCAL_GPIO_Init+0x1e6>
 8000c1a:	a201      	add	r2, pc, #4	; (adr r2, 8000c20 <MCAL_GPIO_Init+0x50>)
 8000c1c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000c20:	08000c41 	.word	0x08000c41
 8000c24:	08000c41 	.word	0x08000c41
 8000c28:	08000c5f 	.word	0x08000c5f
 8000c2c:	08000c91 	.word	0x08000c91
 8000c30:	08000cc5 	.word	0x08000cc5
 8000c34:	08000cfd 	.word	0x08000cfd
 8000c38:	08000d3b 	.word	0x08000d3b
 8000c3c:	08000d79 	.word	0x08000d79
	case Analog_input_Mode:
	case Floating_Mode:
		*Config_Reg |= (Floating_Mode<<(Get_CR_shif(Pin_Config->Pin_Num)+CNF_SHIFT));
 8000c40:	683b      	ldr	r3, [r7, #0]
 8000c42:	781b      	ldrb	r3, [r3, #0]
 8000c44:	4618      	mov	r0, r3
 8000c46:	f7ff ff79 	bl	8000b3c <Get_CR_shif>
 8000c4a:	4603      	mov	r3, r0
 8000c4c:	3302      	adds	r3, #2
 8000c4e:	2201      	movs	r2, #1
 8000c50:	409a      	lsls	r2, r3
 8000c52:	68fb      	ldr	r3, [r7, #12]
 8000c54:	681b      	ldr	r3, [r3, #0]
 8000c56:	431a      	orrs	r2, r3
 8000c58:	68fb      	ldr	r3, [r7, #12]
 8000c5a:	601a      	str	r2, [r3, #0]
		break;
 8000c5c:	e0ab      	b.n	8000db6 <MCAL_GPIO_Init+0x1e6>
	case Input_PU:
		*Config_Reg |= (Input_PU<<(Get_CR_shif(Pin_Config->Pin_Num)+CNF_SHIFT));
 8000c5e:	683b      	ldr	r3, [r7, #0]
 8000c60:	781b      	ldrb	r3, [r3, #0]
 8000c62:	4618      	mov	r0, r3
 8000c64:	f7ff ff6a 	bl	8000b3c <Get_CR_shif>
 8000c68:	4603      	mov	r3, r0
 8000c6a:	3302      	adds	r3, #2
 8000c6c:	2202      	movs	r2, #2
 8000c6e:	409a      	lsls	r2, r3
 8000c70:	68fb      	ldr	r3, [r7, #12]
 8000c72:	681b      	ldr	r3, [r3, #0]
 8000c74:	431a      	orrs	r2, r3
 8000c76:	68fb      	ldr	r3, [r7, #12]
 8000c78:	601a      	str	r2, [r3, #0]
		GPIOx ->ODR |= (1<<Pin_Config->Pin_Num);
 8000c7a:	687b      	ldr	r3, [r7, #4]
 8000c7c:	68db      	ldr	r3, [r3, #12]
 8000c7e:	683a      	ldr	r2, [r7, #0]
 8000c80:	7812      	ldrb	r2, [r2, #0]
 8000c82:	4611      	mov	r1, r2
 8000c84:	2201      	movs	r2, #1
 8000c86:	408a      	lsls	r2, r1
 8000c88:	431a      	orrs	r2, r3
 8000c8a:	687b      	ldr	r3, [r7, #4]
 8000c8c:	60da      	str	r2, [r3, #12]
		break;
 8000c8e:	e092      	b.n	8000db6 <MCAL_GPIO_Init+0x1e6>
	case Input_PD:
		*Config_Reg |= ((Input_PD-1)<<(Get_CR_shif(Pin_Config->Pin_Num)+CNF_SHIFT));
 8000c90:	683b      	ldr	r3, [r7, #0]
 8000c92:	781b      	ldrb	r3, [r3, #0]
 8000c94:	4618      	mov	r0, r3
 8000c96:	f7ff ff51 	bl	8000b3c <Get_CR_shif>
 8000c9a:	4603      	mov	r3, r0
 8000c9c:	3302      	adds	r3, #2
 8000c9e:	2202      	movs	r2, #2
 8000ca0:	409a      	lsls	r2, r3
 8000ca2:	68fb      	ldr	r3, [r7, #12]
 8000ca4:	681b      	ldr	r3, [r3, #0]
 8000ca6:	431a      	orrs	r2, r3
 8000ca8:	68fb      	ldr	r3, [r7, #12]
 8000caa:	601a      	str	r2, [r3, #0]
		GPIOx ->ODR &= ~(1<<Pin_Config->Pin_Num);
 8000cac:	687b      	ldr	r3, [r7, #4]
 8000cae:	68db      	ldr	r3, [r3, #12]
 8000cb0:	683a      	ldr	r2, [r7, #0]
 8000cb2:	7812      	ldrb	r2, [r2, #0]
 8000cb4:	4611      	mov	r1, r2
 8000cb6:	2201      	movs	r2, #1
 8000cb8:	408a      	lsls	r2, r1
 8000cba:	43d2      	mvns	r2, r2
 8000cbc:	401a      	ands	r2, r3
 8000cbe:	687b      	ldr	r3, [r7, #4]
 8000cc0:	60da      	str	r2, [r3, #12]
		break;
 8000cc2:	e078      	b.n	8000db6 <MCAL_GPIO_Init+0x1e6>
	case OUTPUT_PP:
		*Config_Reg |= ((OUTPUT_PP-OUTPUT_MODE_E)<<(Get_CR_shif(Pin_Config->Pin_Num)+CNF_SHIFT));
 8000cc4:	683b      	ldr	r3, [r7, #0]
 8000cc6:	781b      	ldrb	r3, [r3, #0]
 8000cc8:	4618      	mov	r0, r3
 8000cca:	f7ff ff37 	bl	8000b3c <Get_CR_shif>
 8000cce:	2200      	movs	r2, #0
 8000cd0:	68fb      	ldr	r3, [r7, #12]
 8000cd2:	681b      	ldr	r3, [r3, #0]
 8000cd4:	431a      	orrs	r2, r3
 8000cd6:	68fb      	ldr	r3, [r7, #12]
 8000cd8:	601a      	str	r2, [r3, #0]
		*Config_Reg |= ((Pin_Config->speed)<<(Get_CR_shif(Pin_Config->Pin_Num)));
 8000cda:	683b      	ldr	r3, [r7, #0]
 8000cdc:	785b      	ldrb	r3, [r3, #1]
 8000cde:	461c      	mov	r4, r3
 8000ce0:	683b      	ldr	r3, [r7, #0]
 8000ce2:	781b      	ldrb	r3, [r3, #0]
 8000ce4:	4618      	mov	r0, r3
 8000ce6:	f7ff ff29 	bl	8000b3c <Get_CR_shif>
 8000cea:	4603      	mov	r3, r0
 8000cec:	fa04 f203 	lsl.w	r2, r4, r3
 8000cf0:	68fb      	ldr	r3, [r7, #12]
 8000cf2:	681b      	ldr	r3, [r3, #0]
 8000cf4:	431a      	orrs	r2, r3
 8000cf6:	68fb      	ldr	r3, [r7, #12]
 8000cf8:	601a      	str	r2, [r3, #0]
		break;
 8000cfa:	e05c      	b.n	8000db6 <MCAL_GPIO_Init+0x1e6>
	case OUTPUT_OD:
		*Config_Reg |= ((OUTPUT_OD-OUTPUT_MODE_E)<<(Get_CR_shif(Pin_Config->Pin_Num)+CNF_SHIFT));
 8000cfc:	683b      	ldr	r3, [r7, #0]
 8000cfe:	781b      	ldrb	r3, [r3, #0]
 8000d00:	4618      	mov	r0, r3
 8000d02:	f7ff ff1b 	bl	8000b3c <Get_CR_shif>
 8000d06:	4603      	mov	r3, r0
 8000d08:	3302      	adds	r3, #2
 8000d0a:	2201      	movs	r2, #1
 8000d0c:	409a      	lsls	r2, r3
 8000d0e:	68fb      	ldr	r3, [r7, #12]
 8000d10:	681b      	ldr	r3, [r3, #0]
 8000d12:	431a      	orrs	r2, r3
 8000d14:	68fb      	ldr	r3, [r7, #12]
 8000d16:	601a      	str	r2, [r3, #0]
		*Config_Reg |= ((Pin_Config->speed)<<(Get_CR_shif(Pin_Config->Pin_Num)));
 8000d18:	683b      	ldr	r3, [r7, #0]
 8000d1a:	785b      	ldrb	r3, [r3, #1]
 8000d1c:	461c      	mov	r4, r3
 8000d1e:	683b      	ldr	r3, [r7, #0]
 8000d20:	781b      	ldrb	r3, [r3, #0]
 8000d22:	4618      	mov	r0, r3
 8000d24:	f7ff ff0a 	bl	8000b3c <Get_CR_shif>
 8000d28:	4603      	mov	r3, r0
 8000d2a:	fa04 f203 	lsl.w	r2, r4, r3
 8000d2e:	68fb      	ldr	r3, [r7, #12]
 8000d30:	681b      	ldr	r3, [r3, #0]
 8000d32:	431a      	orrs	r2, r3
 8000d34:	68fb      	ldr	r3, [r7, #12]
 8000d36:	601a      	str	r2, [r3, #0]
		break;
 8000d38:	e03d      	b.n	8000db6 <MCAL_GPIO_Init+0x1e6>
	case ALT_OUTPUT_PP:
		*Config_Reg |= ((ALT_OUTPUT_PP-OUTPUT_MODE_E)<<(Get_CR_shif(Pin_Config->Pin_Num)+CNF_SHIFT));
 8000d3a:	683b      	ldr	r3, [r7, #0]
 8000d3c:	781b      	ldrb	r3, [r3, #0]
 8000d3e:	4618      	mov	r0, r3
 8000d40:	f7ff fefc 	bl	8000b3c <Get_CR_shif>
 8000d44:	4603      	mov	r3, r0
 8000d46:	3302      	adds	r3, #2
 8000d48:	2202      	movs	r2, #2
 8000d4a:	409a      	lsls	r2, r3
 8000d4c:	68fb      	ldr	r3, [r7, #12]
 8000d4e:	681b      	ldr	r3, [r3, #0]
 8000d50:	431a      	orrs	r2, r3
 8000d52:	68fb      	ldr	r3, [r7, #12]
 8000d54:	601a      	str	r2, [r3, #0]
		*Config_Reg |= ((Pin_Config->speed)<<(Get_CR_shif(Pin_Config->Pin_Num)));
 8000d56:	683b      	ldr	r3, [r7, #0]
 8000d58:	785b      	ldrb	r3, [r3, #1]
 8000d5a:	461c      	mov	r4, r3
 8000d5c:	683b      	ldr	r3, [r7, #0]
 8000d5e:	781b      	ldrb	r3, [r3, #0]
 8000d60:	4618      	mov	r0, r3
 8000d62:	f7ff feeb 	bl	8000b3c <Get_CR_shif>
 8000d66:	4603      	mov	r3, r0
 8000d68:	fa04 f203 	lsl.w	r2, r4, r3
 8000d6c:	68fb      	ldr	r3, [r7, #12]
 8000d6e:	681b      	ldr	r3, [r3, #0]
 8000d70:	431a      	orrs	r2, r3
 8000d72:	68fb      	ldr	r3, [r7, #12]
 8000d74:	601a      	str	r2, [r3, #0]
		break;
 8000d76:	e01e      	b.n	8000db6 <MCAL_GPIO_Init+0x1e6>
	case ALT_OUTPUT_OD:
		*Config_Reg |= ((ALT_OUTPUT_OD-OUTPUT_MODE_E)<<(Get_CR_shif(Pin_Config->Pin_Num)+CNF_SHIFT));
 8000d78:	683b      	ldr	r3, [r7, #0]
 8000d7a:	781b      	ldrb	r3, [r3, #0]
 8000d7c:	4618      	mov	r0, r3
 8000d7e:	f7ff fedd 	bl	8000b3c <Get_CR_shif>
 8000d82:	4603      	mov	r3, r0
 8000d84:	3302      	adds	r3, #2
 8000d86:	2203      	movs	r2, #3
 8000d88:	409a      	lsls	r2, r3
 8000d8a:	68fb      	ldr	r3, [r7, #12]
 8000d8c:	681b      	ldr	r3, [r3, #0]
 8000d8e:	431a      	orrs	r2, r3
 8000d90:	68fb      	ldr	r3, [r7, #12]
 8000d92:	601a      	str	r2, [r3, #0]
		*Config_Reg |= ((Pin_Config->speed)<<(Get_CR_shif(Pin_Config->Pin_Num)));
 8000d94:	683b      	ldr	r3, [r7, #0]
 8000d96:	785b      	ldrb	r3, [r3, #1]
 8000d98:	461c      	mov	r4, r3
 8000d9a:	683b      	ldr	r3, [r7, #0]
 8000d9c:	781b      	ldrb	r3, [r3, #0]
 8000d9e:	4618      	mov	r0, r3
 8000da0:	f7ff fecc 	bl	8000b3c <Get_CR_shif>
 8000da4:	4603      	mov	r3, r0
 8000da6:	fa04 f203 	lsl.w	r2, r4, r3
 8000daa:	68fb      	ldr	r3, [r7, #12]
 8000dac:	681b      	ldr	r3, [r3, #0]
 8000dae:	431a      	orrs	r2, r3
 8000db0:	68fb      	ldr	r3, [r7, #12]
 8000db2:	601a      	str	r2, [r3, #0]
		break;
 8000db4:	bf00      	nop


	}
}
 8000db6:	bf00      	nop
 8000db8:	3714      	adds	r7, #20
 8000dba:	46bd      	mov	sp, r7
 8000dbc:	bd90      	pop	{r4, r7, pc}
 8000dbe:	bf00      	nop

08000dc0 <MCAL_GPIO_WritePin>:
 * @param[in]	- GPIO_Typedef pointer to port,pin number,value
 * @retval-		- none
 * Note-
 */

void MCAL_GPIO_WritePin(GPIO_Typedef* GPIOx,uint8 Pin_Num,uint8 value){
 8000dc0:	b480      	push	{r7}
 8000dc2:	b083      	sub	sp, #12
 8000dc4:	af00      	add	r7, sp, #0
 8000dc6:	6078      	str	r0, [r7, #4]
 8000dc8:	460b      	mov	r3, r1
 8000dca:	70fb      	strb	r3, [r7, #3]
 8000dcc:	4613      	mov	r3, r2
 8000dce:	70bb      	strb	r3, [r7, #2]

	if(GPIOx != NULL){
 8000dd0:	687b      	ldr	r3, [r7, #4]
 8000dd2:	2b00      	cmp	r3, #0
 8000dd4:	d019      	beq.n	8000e0a <MCAL_GPIO_WritePin+0x4a>
		if(value == PIN_HIGH ){
 8000dd6:	78bb      	ldrb	r3, [r7, #2]
 8000dd8:	2b01      	cmp	r3, #1
 8000dda:	d109      	bne.n	8000df0 <MCAL_GPIO_WritePin+0x30>
			/*Bits 15:0 BSy: Port x Set bit y (y= 0 .. 15)
			These bits are write-only and can be accessed in Word mode only.
			0: No action on the corresponding ODRx bit
			1: Set the corresponding ODRx bit*/
			GPIOx->ODR |= (PIN_HIGH<<Pin_Num);
 8000ddc:	687b      	ldr	r3, [r7, #4]
 8000dde:	68da      	ldr	r2, [r3, #12]
 8000de0:	78fb      	ldrb	r3, [r7, #3]
 8000de2:	2101      	movs	r1, #1
 8000de4:	fa01 f303 	lsl.w	r3, r1, r3
 8000de8:	431a      	orrs	r2, r3
 8000dea:	687b      	ldr	r3, [r7, #4]
 8000dec:	60da      	str	r2, [r3, #12]

			GPIOx->ODR &= ~(1<<Pin_Num);
		}
	}

}
 8000dee:	e00c      	b.n	8000e0a <MCAL_GPIO_WritePin+0x4a>
		}else if(value == PIN_LOW){
 8000df0:	78bb      	ldrb	r3, [r7, #2]
 8000df2:	2b00      	cmp	r3, #0
 8000df4:	d109      	bne.n	8000e0a <MCAL_GPIO_WritePin+0x4a>
			GPIOx->ODR &= ~(1<<Pin_Num);
 8000df6:	687b      	ldr	r3, [r7, #4]
 8000df8:	68db      	ldr	r3, [r3, #12]
 8000dfa:	78fa      	ldrb	r2, [r7, #3]
 8000dfc:	2101      	movs	r1, #1
 8000dfe:	fa01 f202 	lsl.w	r2, r1, r2
 8000e02:	43d2      	mvns	r2, r2
 8000e04:	401a      	ands	r2, r3
 8000e06:	687b      	ldr	r3, [r7, #4]
 8000e08:	60da      	str	r2, [r3, #12]
}
 8000e0a:	bf00      	nop
 8000e0c:	370c      	adds	r7, #12
 8000e0e:	46bd      	mov	sp, r7
 8000e10:	bc80      	pop	{r7}
 8000e12:	4770      	bx	lr

08000e14 <EXTI0_IRQHandler>:
}




void EXTI0_IRQHandler(void){
 8000e14:	b580      	push	{r7, lr}
 8000e16:	af00      	add	r7, sp, #0
		1: selected trigger request occurred
		This bit is set when the selected edge event arrives on the external interrupt line. This bit is
		cleared by writing a 1 into the bit.
		Note: Bit 19 is used in connectivity line devices only and is reserved otherwise.
	 */
	EXTI->EXTI_PR |=(1<<EXTI_0);
 8000e18:	4b05      	ldr	r3, [pc, #20]	; (8000e30 <EXTI0_IRQHandler+0x1c>)
 8000e1a:	695b      	ldr	r3, [r3, #20]
 8000e1c:	4a04      	ldr	r2, [pc, #16]	; (8000e30 <EXTI0_IRQHandler+0x1c>)
 8000e1e:	f043 0301 	orr.w	r3, r3, #1
 8000e22:	6153      	str	r3, [r2, #20]
	GP_CallBack[EXTI_0]();
 8000e24:	4b03      	ldr	r3, [pc, #12]	; (8000e34 <EXTI0_IRQHandler+0x20>)
 8000e26:	681b      	ldr	r3, [r3, #0]
 8000e28:	4798      	blx	r3
}
 8000e2a:	bf00      	nop
 8000e2c:	bd80      	pop	{r7, pc}
 8000e2e:	bf00      	nop
 8000e30:	40010400 	.word	0x40010400
 8000e34:	20000048 	.word	0x20000048

08000e38 <EXTI1_IRQHandler>:
void EXTI1_IRQHandler(void){
 8000e38:	b580      	push	{r7, lr}
 8000e3a:	af00      	add	r7, sp, #0
			1: selected trigger request occurred
			This bit is set when the selected edge event arrives on the external interrupt line. This bit is
			cleared by writing a 1 into the bit.
			Note: Bit 19 is used in connectivity line devices only and is reserved otherwise.
	 */
	EXTI->EXTI_PR |=(1<<EXTI_1);
 8000e3c:	4b05      	ldr	r3, [pc, #20]	; (8000e54 <EXTI1_IRQHandler+0x1c>)
 8000e3e:	695b      	ldr	r3, [r3, #20]
 8000e40:	4a04      	ldr	r2, [pc, #16]	; (8000e54 <EXTI1_IRQHandler+0x1c>)
 8000e42:	f043 0302 	orr.w	r3, r3, #2
 8000e46:	6153      	str	r3, [r2, #20]
	GP_CallBack[EXTI_1]();
 8000e48:	4b03      	ldr	r3, [pc, #12]	; (8000e58 <EXTI1_IRQHandler+0x20>)
 8000e4a:	685b      	ldr	r3, [r3, #4]
 8000e4c:	4798      	blx	r3
}
 8000e4e:	bf00      	nop
 8000e50:	bd80      	pop	{r7, pc}
 8000e52:	bf00      	nop
 8000e54:	40010400 	.word	0x40010400
 8000e58:	20000048 	.word	0x20000048

08000e5c <EXTI2_IRQHandler>:
void EXTI2_IRQHandler(void){
 8000e5c:	b580      	push	{r7, lr}
 8000e5e:	af00      	add	r7, sp, #0
			1: selected trigger request occurred
			This bit is set when the selected edge event arrives on the external interrupt line. This bit is
			cleared by writing a 1 into the bit.
			Note: Bit 19 is used in connectivity line devices only and is reserved otherwise.
	 */
	EXTI->EXTI_PR |=(1<<EXTI_2);
 8000e60:	4b05      	ldr	r3, [pc, #20]	; (8000e78 <EXTI2_IRQHandler+0x1c>)
 8000e62:	695b      	ldr	r3, [r3, #20]
 8000e64:	4a04      	ldr	r2, [pc, #16]	; (8000e78 <EXTI2_IRQHandler+0x1c>)
 8000e66:	f043 0304 	orr.w	r3, r3, #4
 8000e6a:	6153      	str	r3, [r2, #20]
	GP_CallBack[EXTI_2]();
 8000e6c:	4b03      	ldr	r3, [pc, #12]	; (8000e7c <EXTI2_IRQHandler+0x20>)
 8000e6e:	689b      	ldr	r3, [r3, #8]
 8000e70:	4798      	blx	r3
}
 8000e72:	bf00      	nop
 8000e74:	bd80      	pop	{r7, pc}
 8000e76:	bf00      	nop
 8000e78:	40010400 	.word	0x40010400
 8000e7c:	20000048 	.word	0x20000048

08000e80 <EXTI3_IRQHandler>:
void EXTI3_IRQHandler(void){
 8000e80:	b580      	push	{r7, lr}
 8000e82:	af00      	add	r7, sp, #0
			1: selected trigger request occurred
			This bit is set when the selected edge event arrives on the external interrupt line. This bit is
			cleared by writing a 1 into the bit.
			Note: Bit 19 is used in connectivity line devices only and is reserved otherwise.
	 */
	EXTI->EXTI_PR |=(1<<EXTI_3);
 8000e84:	4b05      	ldr	r3, [pc, #20]	; (8000e9c <EXTI3_IRQHandler+0x1c>)
 8000e86:	695b      	ldr	r3, [r3, #20]
 8000e88:	4a04      	ldr	r2, [pc, #16]	; (8000e9c <EXTI3_IRQHandler+0x1c>)
 8000e8a:	f043 0308 	orr.w	r3, r3, #8
 8000e8e:	6153      	str	r3, [r2, #20]
	GP_CallBack[EXTI_3]();
 8000e90:	4b03      	ldr	r3, [pc, #12]	; (8000ea0 <EXTI3_IRQHandler+0x20>)
 8000e92:	68db      	ldr	r3, [r3, #12]
 8000e94:	4798      	blx	r3
}
 8000e96:	bf00      	nop
 8000e98:	bd80      	pop	{r7, pc}
 8000e9a:	bf00      	nop
 8000e9c:	40010400 	.word	0x40010400
 8000ea0:	20000048 	.word	0x20000048

08000ea4 <EXTI4_IRQHandler>:
void EXTI4_IRQHandler(void){
 8000ea4:	b580      	push	{r7, lr}
 8000ea6:	af00      	add	r7, sp, #0
			1: selected trigger request occurred
			This bit is set when the selected edge event arrives on the external interrupt line. This bit is
			cleared by writing a 1 into the bit.
			Note: Bit 19 is used in connectivity line devices only and is reserved otherwise.
	 */
	EXTI->EXTI_PR |=(1<<EXTI_4);
 8000ea8:	4b05      	ldr	r3, [pc, #20]	; (8000ec0 <EXTI4_IRQHandler+0x1c>)
 8000eaa:	695b      	ldr	r3, [r3, #20]
 8000eac:	4a04      	ldr	r2, [pc, #16]	; (8000ec0 <EXTI4_IRQHandler+0x1c>)
 8000eae:	f043 0310 	orr.w	r3, r3, #16
 8000eb2:	6153      	str	r3, [r2, #20]

	GP_CallBack[EXTI_4]();
 8000eb4:	4b03      	ldr	r3, [pc, #12]	; (8000ec4 <EXTI4_IRQHandler+0x20>)
 8000eb6:	691b      	ldr	r3, [r3, #16]
 8000eb8:	4798      	blx	r3
}
 8000eba:	bf00      	nop
 8000ebc:	bd80      	pop	{r7, pc}
 8000ebe:	bf00      	nop
 8000ec0:	40010400 	.word	0x40010400
 8000ec4:	20000048 	.word	0x20000048

08000ec8 <EXTI9_5_IRQHandler>:
void EXTI9_5_IRQHandler(void){
 8000ec8:	b580      	push	{r7, lr}
 8000eca:	af00      	add	r7, sp, #0
			1: selected trigger request occurred
			This bit is set when the selected edge event arrives on the external interrupt line. This bit is
			cleared by writing a 1 into the bit.
			Note: Bit 19 is used in connectivity line devices only and is reserved otherwise.
	 */
	if(EXTI->EXTI_PR & (1<<EXTI_5)){
 8000ecc:	4b26      	ldr	r3, [pc, #152]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000ece:	695b      	ldr	r3, [r3, #20]
 8000ed0:	f003 0320 	and.w	r3, r3, #32
 8000ed4:	2b00      	cmp	r3, #0
 8000ed6:	d008      	beq.n	8000eea <EXTI9_5_IRQHandler+0x22>
		EXTI->EXTI_PR |=(1<<EXTI_5);
 8000ed8:	4b23      	ldr	r3, [pc, #140]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000eda:	695b      	ldr	r3, [r3, #20]
 8000edc:	4a22      	ldr	r2, [pc, #136]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000ede:	f043 0320 	orr.w	r3, r3, #32
 8000ee2:	6153      	str	r3, [r2, #20]
		GP_CallBack[EXTI_5]();
 8000ee4:	4b21      	ldr	r3, [pc, #132]	; (8000f6c <EXTI9_5_IRQHandler+0xa4>)
 8000ee6:	695b      	ldr	r3, [r3, #20]
 8000ee8:	4798      	blx	r3
	}if(EXTI->EXTI_PR & (1<<EXTI_6)){
 8000eea:	4b1f      	ldr	r3, [pc, #124]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000eec:	695b      	ldr	r3, [r3, #20]
 8000eee:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000ef2:	2b00      	cmp	r3, #0
 8000ef4:	d008      	beq.n	8000f08 <EXTI9_5_IRQHandler+0x40>
		EXTI->EXTI_PR |=(1<<EXTI_6);
 8000ef6:	4b1c      	ldr	r3, [pc, #112]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000ef8:	695b      	ldr	r3, [r3, #20]
 8000efa:	4a1b      	ldr	r2, [pc, #108]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000efc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000f00:	6153      	str	r3, [r2, #20]
		GP_CallBack[EXTI_6]();
 8000f02:	4b1a      	ldr	r3, [pc, #104]	; (8000f6c <EXTI9_5_IRQHandler+0xa4>)
 8000f04:	699b      	ldr	r3, [r3, #24]
 8000f06:	4798      	blx	r3
	}if(EXTI->EXTI_PR & (1<<EXTI_7)){
 8000f08:	4b17      	ldr	r3, [pc, #92]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000f0a:	695b      	ldr	r3, [r3, #20]
 8000f0c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000f10:	2b00      	cmp	r3, #0
 8000f12:	d008      	beq.n	8000f26 <EXTI9_5_IRQHandler+0x5e>
		EXTI->EXTI_PR |=(1<<EXTI_7);
 8000f14:	4b14      	ldr	r3, [pc, #80]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000f16:	695b      	ldr	r3, [r3, #20]
 8000f18:	4a13      	ldr	r2, [pc, #76]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000f1a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000f1e:	6153      	str	r3, [r2, #20]
		GP_CallBack[EXTI_7]();
 8000f20:	4b12      	ldr	r3, [pc, #72]	; (8000f6c <EXTI9_5_IRQHandler+0xa4>)
 8000f22:	69db      	ldr	r3, [r3, #28]
 8000f24:	4798      	blx	r3
	}if(EXTI->EXTI_PR & (1<<EXTI_8)){
 8000f26:	4b10      	ldr	r3, [pc, #64]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000f28:	695b      	ldr	r3, [r3, #20]
 8000f2a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8000f2e:	2b00      	cmp	r3, #0
 8000f30:	d008      	beq.n	8000f44 <EXTI9_5_IRQHandler+0x7c>
		EXTI->EXTI_PR |=(1<<EXTI_8);
 8000f32:	4b0d      	ldr	r3, [pc, #52]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000f34:	695b      	ldr	r3, [r3, #20]
 8000f36:	4a0c      	ldr	r2, [pc, #48]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000f38:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000f3c:	6153      	str	r3, [r2, #20]
		GP_CallBack[EXTI_8]();
 8000f3e:	4b0b      	ldr	r3, [pc, #44]	; (8000f6c <EXTI9_5_IRQHandler+0xa4>)
 8000f40:	6a1b      	ldr	r3, [r3, #32]
 8000f42:	4798      	blx	r3
	}if(EXTI->EXTI_PR & (1<<EXTI_9)){
 8000f44:	4b08      	ldr	r3, [pc, #32]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000f46:	695b      	ldr	r3, [r3, #20]
 8000f48:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8000f4c:	2b00      	cmp	r3, #0
 8000f4e:	d008      	beq.n	8000f62 <EXTI9_5_IRQHandler+0x9a>
		EXTI->EXTI_PR |=(1<<EXTI_9);
 8000f50:	4b05      	ldr	r3, [pc, #20]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000f52:	695b      	ldr	r3, [r3, #20]
 8000f54:	4a04      	ldr	r2, [pc, #16]	; (8000f68 <EXTI9_5_IRQHandler+0xa0>)
 8000f56:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000f5a:	6153      	str	r3, [r2, #20]
		GP_CallBack[EXTI_9]();
 8000f5c:	4b03      	ldr	r3, [pc, #12]	; (8000f6c <EXTI9_5_IRQHandler+0xa4>)
 8000f5e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000f60:	4798      	blx	r3
	}
}
 8000f62:	bf00      	nop
 8000f64:	bd80      	pop	{r7, pc}
 8000f66:	bf00      	nop
 8000f68:	40010400 	.word	0x40010400
 8000f6c:	20000048 	.word	0x20000048

08000f70 <EXTI15_10_IRQHandler>:
void EXTI15_10_IRQHandler(void){
 8000f70:	b580      	push	{r7, lr}
 8000f72:	af00      	add	r7, sp, #0
			1: selected trigger request occurred
			This bit is set when the selected edge event arrives on the external interrupt line. This bit is
			cleared by writing a 1 into the bit.
			Note: Bit 19 is used in connectivity line devices only and is reserved otherwise.
	 */
	if(EXTI->EXTI_PR & (1<<EXTI_10)){
 8000f74:	4b2d      	ldr	r3, [pc, #180]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000f76:	695b      	ldr	r3, [r3, #20]
 8000f78:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8000f7c:	2b00      	cmp	r3, #0
 8000f7e:	d008      	beq.n	8000f92 <EXTI15_10_IRQHandler+0x22>
		EXTI->EXTI_PR |=(1<<EXTI_10);
 8000f80:	4b2a      	ldr	r3, [pc, #168]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000f82:	695b      	ldr	r3, [r3, #20]
 8000f84:	4a29      	ldr	r2, [pc, #164]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000f86:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000f8a:	6153      	str	r3, [r2, #20]
		GP_CallBack[EXTI_10]();
 8000f8c:	4b28      	ldr	r3, [pc, #160]	; (8001030 <EXTI15_10_IRQHandler+0xc0>)
 8000f8e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000f90:	4798      	blx	r3
	}if(EXTI->EXTI_PR & (1<<EXTI_11)){
 8000f92:	4b26      	ldr	r3, [pc, #152]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000f94:	695b      	ldr	r3, [r3, #20]
 8000f96:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8000f9a:	2b00      	cmp	r3, #0
 8000f9c:	d008      	beq.n	8000fb0 <EXTI15_10_IRQHandler+0x40>
		EXTI->EXTI_PR |=(1<<EXTI_11);
 8000f9e:	4b23      	ldr	r3, [pc, #140]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000fa0:	695b      	ldr	r3, [r3, #20]
 8000fa2:	4a22      	ldr	r2, [pc, #136]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000fa4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000fa8:	6153      	str	r3, [r2, #20]
		GP_CallBack[EXTI_11]();
 8000faa:	4b21      	ldr	r3, [pc, #132]	; (8001030 <EXTI15_10_IRQHandler+0xc0>)
 8000fac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000fae:	4798      	blx	r3
	}if(EXTI->EXTI_PR & (1<<EXTI_12)){
 8000fb0:	4b1e      	ldr	r3, [pc, #120]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000fb2:	695b      	ldr	r3, [r3, #20]
 8000fb4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8000fb8:	2b00      	cmp	r3, #0
 8000fba:	d008      	beq.n	8000fce <EXTI15_10_IRQHandler+0x5e>
		EXTI->EXTI_PR |=(1<<EXTI_12);
 8000fbc:	4b1b      	ldr	r3, [pc, #108]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000fbe:	695b      	ldr	r3, [r3, #20]
 8000fc0:	4a1a      	ldr	r2, [pc, #104]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000fc2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000fc6:	6153      	str	r3, [r2, #20]
		GP_CallBack[EXTI_12]();
 8000fc8:	4b19      	ldr	r3, [pc, #100]	; (8001030 <EXTI15_10_IRQHandler+0xc0>)
 8000fca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000fcc:	4798      	blx	r3
	}if(EXTI->EXTI_PR & (1<<EXTI_13)){
 8000fce:	4b17      	ldr	r3, [pc, #92]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000fd0:	695b      	ldr	r3, [r3, #20]
 8000fd2:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8000fd6:	2b00      	cmp	r3, #0
 8000fd8:	d008      	beq.n	8000fec <EXTI15_10_IRQHandler+0x7c>
		EXTI->EXTI_PR |=(1<<EXTI_13);
 8000fda:	4b14      	ldr	r3, [pc, #80]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000fdc:	695b      	ldr	r3, [r3, #20]
 8000fde:	4a13      	ldr	r2, [pc, #76]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000fe0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000fe4:	6153      	str	r3, [r2, #20]
		GP_CallBack[EXTI_13]();
 8000fe6:	4b12      	ldr	r3, [pc, #72]	; (8001030 <EXTI15_10_IRQHandler+0xc0>)
 8000fe8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8000fea:	4798      	blx	r3
	}if(EXTI->EXTI_PR & (1<<EXTI_14)){
 8000fec:	4b0f      	ldr	r3, [pc, #60]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000fee:	695b      	ldr	r3, [r3, #20]
 8000ff0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8000ff4:	2b00      	cmp	r3, #0
 8000ff6:	d008      	beq.n	800100a <EXTI15_10_IRQHandler+0x9a>
		EXTI->EXTI_PR |=(1<<EXTI_14);
 8000ff8:	4b0c      	ldr	r3, [pc, #48]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000ffa:	695b      	ldr	r3, [r3, #20]
 8000ffc:	4a0b      	ldr	r2, [pc, #44]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8000ffe:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001002:	6153      	str	r3, [r2, #20]
		GP_CallBack[EXTI_14]();
 8001004:	4b0a      	ldr	r3, [pc, #40]	; (8001030 <EXTI15_10_IRQHandler+0xc0>)
 8001006:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001008:	4798      	blx	r3
	}if(EXTI->EXTI_PR & (1<<EXTI_15)){
 800100a:	4b08      	ldr	r3, [pc, #32]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 800100c:	695b      	ldr	r3, [r3, #20]
 800100e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8001012:	2b00      	cmp	r3, #0
 8001014:	d008      	beq.n	8001028 <EXTI15_10_IRQHandler+0xb8>
		EXTI->EXTI_PR |=(1<<EXTI_15);
 8001016:	4b05      	ldr	r3, [pc, #20]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 8001018:	695b      	ldr	r3, [r3, #20]
 800101a:	4a04      	ldr	r2, [pc, #16]	; (800102c <EXTI15_10_IRQHandler+0xbc>)
 800101c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001020:	6153      	str	r3, [r2, #20]
		GP_CallBack[EXTI_15]();
 8001022:	4b03      	ldr	r3, [pc, #12]	; (8001030 <EXTI15_10_IRQHandler+0xc0>)
 8001024:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001026:	4798      	blx	r3
	}
}
 8001028:	bf00      	nop
 800102a:	bd80      	pop	{r7, pc}
 800102c:	40010400 	.word	0x40010400
 8001030:	20000048 	.word	0x20000048

08001034 <main>:
 */

#include "HC-05.h"
#include "DC_Motors.h"
int main(void)
{
 8001034:	b580      	push	{r7, lr}
 8001036:	af00      	add	r7, sp, #0
	HAL_HC05_Init();
 8001038:	f7ff fa06 	bl	8000448 <HAL_HC05_Init>
	Dc_Motors_Init();
 800103c:	f7ff f898 	bl	8000170 <Dc_Motors_Init>


	while(1){

		switch(Received_char){
 8001040:	4b3a      	ldr	r3, [pc, #232]	; (800112c <main+0xf8>)
 8001042:	881b      	ldrh	r3, [r3, #0]
 8001044:	3b42      	subs	r3, #66	; 0x42
 8001046:	2b11      	cmp	r3, #17
 8001048:	d86c      	bhi.n	8001124 <main+0xf0>
 800104a:	a201      	add	r2, pc, #4	; (adr r2, 8001050 <main+0x1c>)
 800104c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8001050:	080010c1 	.word	0x080010c1
 8001054:	08001125 	.word	0x08001125
 8001058:	08001125 	.word	0x08001125
 800105c:	08001125 	.word	0x08001125
 8001060:	08001099 	.word	0x08001099
 8001064:	08001125 	.word	0x08001125
 8001068:	08001125 	.word	0x08001125
 800106c:	08001125 	.word	0x08001125
 8001070:	08001125 	.word	0x08001125
 8001074:	08001125 	.word	0x08001125
 8001078:	080010e3 	.word	0x080010e3
 800107c:	08001125 	.word	0x08001125
 8001080:	08001125 	.word	0x08001125
 8001084:	08001125 	.word	0x08001125
 8001088:	08001125 	.word	0x08001125
 800108c:	08001125 	.word	0x08001125
 8001090:	08001105 	.word	0x08001105
 8001094:	080010bb 	.word	0x080010bb
		case 'F':{
		DC_Motor_Move_Stop(M1,Clock_Wise);
 8001098:	2101      	movs	r1, #1
 800109a:	2000      	movs	r0, #0
 800109c:	f7ff f8dc 	bl	8000258 <DC_Motor_Move_Stop>
		DC_Motor_Move_Stop(M2,Clock_Wise);
 80010a0:	2101      	movs	r1, #1
 80010a2:	2001      	movs	r0, #1
 80010a4:	f7ff f8d8 	bl	8000258 <DC_Motor_Move_Stop>
		DC_Motor_Move_Stop(M3,Clock_Wise);
 80010a8:	2101      	movs	r1, #1
 80010aa:	2002      	movs	r0, #2
 80010ac:	f7ff f8d4 	bl	8000258 <DC_Motor_Move_Stop>
		DC_Motor_Move_Stop(M4,Clock_Wise);
 80010b0:	2101      	movs	r1, #1
 80010b2:	2003      	movs	r0, #3
 80010b4:	f7ff f8d0 	bl	8000258 <DC_Motor_Move_Stop>

		break;
 80010b8:	e037      	b.n	800112a <main+0xf6>
		}
		case 'S':
			Stop_CAR();
 80010ba:	f7ff f995 	bl	80003e8 <Stop_CAR>
			break;
 80010be:	e034      	b.n	800112a <main+0xf6>
		case 'B':{
			DC_Motor_Move_Stop(M1,CounterClock_Wise);
 80010c0:	2102      	movs	r1, #2
 80010c2:	2000      	movs	r0, #0
 80010c4:	f7ff f8c8 	bl	8000258 <DC_Motor_Move_Stop>
			DC_Motor_Move_Stop(M2,CounterClock_Wise);
 80010c8:	2102      	movs	r1, #2
 80010ca:	2001      	movs	r0, #1
 80010cc:	f7ff f8c4 	bl	8000258 <DC_Motor_Move_Stop>
			DC_Motor_Move_Stop(M3,CounterClock_Wise);
 80010d0:	2102      	movs	r1, #2
 80010d2:	2002      	movs	r0, #2
 80010d4:	f7ff f8c0 	bl	8000258 <DC_Motor_Move_Stop>
			DC_Motor_Move_Stop(M4,CounterClock_Wise);
 80010d8:	2102      	movs	r1, #2
 80010da:	2003      	movs	r0, #3
 80010dc:	f7ff f8bc 	bl	8000258 <DC_Motor_Move_Stop>
			break;
 80010e0:	e023      	b.n	800112a <main+0xf6>
		}
		case 'L':{
			DC_Motor_Move_Stop(M1,CounterClock_Wise);
 80010e2:	2102      	movs	r1, #2
 80010e4:	2000      	movs	r0, #0
 80010e6:	f7ff f8b7 	bl	8000258 <DC_Motor_Move_Stop>
			DC_Motor_Move_Stop(M2,Clock_Wise);
 80010ea:	2101      	movs	r1, #1
 80010ec:	2001      	movs	r0, #1
 80010ee:	f7ff f8b3 	bl	8000258 <DC_Motor_Move_Stop>
			DC_Motor_Move_Stop(M3,CounterClock_Wise);
 80010f2:	2102      	movs	r1, #2
 80010f4:	2002      	movs	r0, #2
 80010f6:	f7ff f8af 	bl	8000258 <DC_Motor_Move_Stop>
			DC_Motor_Move_Stop(M4,Clock_Wise);
 80010fa:	2101      	movs	r1, #1
 80010fc:	2003      	movs	r0, #3
 80010fe:	f7ff f8ab 	bl	8000258 <DC_Motor_Move_Stop>
			break;
 8001102:	e012      	b.n	800112a <main+0xf6>
		}
		case 'R':{
			DC_Motor_Move_Stop(M1,Clock_Wise);
 8001104:	2101      	movs	r1, #1
 8001106:	2000      	movs	r0, #0
 8001108:	f7ff f8a6 	bl	8000258 <DC_Motor_Move_Stop>
			DC_Motor_Move_Stop(M2,CounterClock_Wise);
 800110c:	2102      	movs	r1, #2
 800110e:	2001      	movs	r0, #1
 8001110:	f7ff f8a2 	bl	8000258 <DC_Motor_Move_Stop>
			DC_Motor_Move_Stop(M3,Clock_Wise);
 8001114:	2101      	movs	r1, #1
 8001116:	2002      	movs	r0, #2
 8001118:	f7ff f89e 	bl	8000258 <DC_Motor_Move_Stop>
			DC_Motor_Move_Stop(M4,CounterClock_Wise);
 800111c:	2102      	movs	r1, #2
 800111e:	2003      	movs	r0, #3
 8001120:	f7ff f89a 	bl	8000258 <DC_Motor_Move_Stop>
		}
		default :
			Stop_CAR();
 8001124:	f7ff f960 	bl	80003e8 <Stop_CAR>
			break;
 8001128:	bf00      	nop
		switch(Received_char){
 800112a:	e789      	b.n	8001040 <main+0xc>
 800112c:	20000034 	.word	0x20000034

08001130 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8001130:	480d      	ldr	r0, [pc, #52]	; (8001168 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8001132:	4685      	mov	sp, r0
/* Call the clock system intitialization function.*/
  bl  SystemInit
 8001134:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8001138:	480c      	ldr	r0, [pc, #48]	; (800116c <LoopForever+0x6>)
  ldr r1, =_edata
 800113a:	490d      	ldr	r1, [pc, #52]	; (8001170 <LoopForever+0xa>)
  ldr r2, =_sidata
 800113c:	4a0d      	ldr	r2, [pc, #52]	; (8001174 <LoopForever+0xe>)
  movs r3, #0
 800113e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001140:	e002      	b.n	8001148 <LoopCopyDataInit>

08001142 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001142:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001144:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001146:	3304      	adds	r3, #4

08001148 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001148:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800114a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800114c:	d3f9      	bcc.n	8001142 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800114e:	4a0a      	ldr	r2, [pc, #40]	; (8001178 <LoopForever+0x12>)
  ldr r4, =_ebss
 8001150:	4c0a      	ldr	r4, [pc, #40]	; (800117c <LoopForever+0x16>)
  movs r3, #0
 8001152:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001154:	e001      	b.n	800115a <LoopFillZerobss>

08001156 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001156:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001158:	3204      	adds	r2, #4

0800115a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800115a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800115c:	d3fb      	bcc.n	8001156 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 800115e:	f000 f811 	bl	8001184 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8001162:	f7ff ff67 	bl	8001034 <main>

08001166 <LoopForever>:

LoopForever:
    b LoopForever
 8001166:	e7fe      	b.n	8001166 <LoopForever>
  ldr   r0, =_estack
 8001168:	20005000 	.word	0x20005000
  ldr r0, =_sdata
 800116c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001170:	20000018 	.word	0x20000018
  ldr r2, =_sidata
 8001174:	08001200 	.word	0x08001200
  ldr r2, =_sbss
 8001178:	20000018 	.word	0x20000018
  ldr r4, =_ebss
 800117c:	20000084 	.word	0x20000084

08001180 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8001180:	e7fe      	b.n	8001180 <ADC1_2_IRQHandler>
	...

08001184 <__libc_init_array>:
 8001184:	b570      	push	{r4, r5, r6, lr}
 8001186:	2500      	movs	r5, #0
 8001188:	4e0c      	ldr	r6, [pc, #48]	; (80011bc <__libc_init_array+0x38>)
 800118a:	4c0d      	ldr	r4, [pc, #52]	; (80011c0 <__libc_init_array+0x3c>)
 800118c:	1ba4      	subs	r4, r4, r6
 800118e:	10a4      	asrs	r4, r4, #2
 8001190:	42a5      	cmp	r5, r4
 8001192:	d109      	bne.n	80011a8 <__libc_init_array+0x24>
 8001194:	f000 f81a 	bl	80011cc <_init>
 8001198:	2500      	movs	r5, #0
 800119a:	4e0a      	ldr	r6, [pc, #40]	; (80011c4 <__libc_init_array+0x40>)
 800119c:	4c0a      	ldr	r4, [pc, #40]	; (80011c8 <__libc_init_array+0x44>)
 800119e:	1ba4      	subs	r4, r4, r6
 80011a0:	10a4      	asrs	r4, r4, #2
 80011a2:	42a5      	cmp	r5, r4
 80011a4:	d105      	bne.n	80011b2 <__libc_init_array+0x2e>
 80011a6:	bd70      	pop	{r4, r5, r6, pc}
 80011a8:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80011ac:	4798      	blx	r3
 80011ae:	3501      	adds	r5, #1
 80011b0:	e7ee      	b.n	8001190 <__libc_init_array+0xc>
 80011b2:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80011b6:	4798      	blx	r3
 80011b8:	3501      	adds	r5, #1
 80011ba:	e7f2      	b.n	80011a2 <__libc_init_array+0x1e>
 80011bc:	080011f8 	.word	0x080011f8
 80011c0:	080011f8 	.word	0x080011f8
 80011c4:	080011f8 	.word	0x080011f8
 80011c8:	080011fc 	.word	0x080011fc

080011cc <_init>:
 80011cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80011ce:	bf00      	nop
 80011d0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80011d2:	bc08      	pop	{r3}
 80011d4:	469e      	mov	lr, r3
 80011d6:	4770      	bx	lr

080011d8 <_fini>:
 80011d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80011da:	bf00      	nop
 80011dc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80011de:	bc08      	pop	{r3}
 80011e0:	469e      	mov	lr, r3
 80011e2:	4770      	bx	lr
